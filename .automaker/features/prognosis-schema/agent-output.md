
ðŸ”§ Tool: TodoWrite
Input: {
  "todos": [
    {
      "content": "Explore existing codebase structure and patterns",
      "status": "in_progress",
      "activeForm": "Exploring existing codebase structure and patterns"
    },
    {
      "content": "Design prognosis tracking schema",
      "status": "pending",
      "activeForm": "Designing prognosis tracking schema"
    },
    {
      "content": "Implement prognosis schema file",
      "status": "pending",
      "activeForm": "Implementing prognosis schema file"
    },
    {
      "content": "Create database migration",
      "status": "pending",
      "activeForm": "Creating database migration"
    },
    {
      "content": "Add schema to index exports",
      "status": "pending",
      "activeForm": "Adding schema to index exports"
    },
    {
      "content": "Create prognosis controller",
      "status": "pending",
      "activeForm": "Creating prognosis controller"
    },
    {
      "content": "Create prognosis routes",
      "status": "pending",
      "activeForm": "Creating prognosis routes"
    },
    {
      "content": "Register routes in API",
      "status": "pending",
      "activeForm": "Registering routes in API"
    },
    {
      "content": "Verify implementation with Playwright test",
      "status": "pending",
      "activeForm": "Verifying implementation with Playwright test"
    }
  ]
}

Let me explore the existing codebase structure to understand the patterns used for schemas, controllers, and routes.

ðŸ”§ Tool: Glob
Input: {
  "pattern": "services/api/src/db/schemas/*.schema.js"
}

ðŸ”§ Tool: Glob
Input: {
  "pattern": "services/api/src/controllers/*.controller.js"
}

ðŸ”§ Tool: Glob
Input: {
  "pattern": "services/api/src/routes/*.routes.js"
}

I can see there's already a `prognosis.schema.js` file. Let me examine it along with related prognosis files to understand what exists and what enhancements are needed.

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/prognosis.schema.js"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/prognosisCaregiver.schema.js"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/prognosisImminence.schema.js"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/prognosisPatient.schema.js"
}

I see the existing prognosis schema is quite basic. Let me look at more comprehensive schema examples and the index file to understand the patterns better.

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/index.js"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/hopeAssessments.schema.js"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/encounters.schema.js"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/controllers/Prognosis.controller.js"
}

Now let me check the existing routes and API routes file to understand the registration pattern.

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/routes/api.routes.js"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/primaryDiagnosis.schema.js"
}

Let me also check the existing Prognosis routes to understand the structure.

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/routes/patient/Prognosis.routes.js"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/vitalSign.schema.js"
}

Now let me check the existing Prognosis controller in the patient folder.

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/controllers/patient/Prognosis.controller.js"
}

ðŸ”§ Tool: Glob
Input: {
  "pattern": "services/api/database/migrations/drizzle/*.sql"
}

Now I have a complete understanding of the codebase. Let me update my todo list and start implementing the comprehensive prognosis tracking schema.

ðŸ”§ Tool: TodoWrite
Input: {
  "todos": [
    {
      "content": "Explore existing codebase structure and patterns",
      "status": "completed",
      "activeForm": "Exploring existing codebase structure and patterns"
    },
    {
      "content": "Create comprehensive prognosis tracking schema",
      "status": "in_progress",
      "activeForm": "Creating comprehensive prognosis tracking schema"
    },
    {
      "content": "Create database migration",
      "status": "pending",
      "activeForm": "Creating database migration"
    },
    {
      "content": "Add schema to index exports",
      "status": "pending",
      "activeForm": "Adding schema to index exports"
    },
    {
      "content": "Update prognosis controller with new functionality",
      "status": "pending",
      "activeForm": "Updating prognosis controller with new functionality"
    },
    {
      "content": "Update prognosis routes",
      "status": "pending",
      "activeForm": "Updating prognosis routes"
    },
    {
      "content": "Verify implementation with Playwright test",
      "status": "pending",
      "activeForm": "Verifying implementation with Playwright test"
    }
  ]
}

Now I'll create a new comprehensive prognosis tracking schema. The existing prognosis schema is quite basic, so I'll create a new enhanced schema file.

ðŸ”§ Tool: Write
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/prognosisTracking.schema.js",
  "content": "import { pgTable, bigint, integer, varchar, decimal, timestamp, text, boolean, jsonb, date, index } from 'drizzle-orm/pg-core';\nimport { patients } from './patient.schema.js';\nimport { users } from './user.schema.js';\n\n// ============================================================================\n// COMPREHENSIVE PROGNOSIS TRACKING SCHEMA\n// ============================================================================\n// Tracks patient prognosis information for hospice care, including:\n// - Expected length of stay with date ranges\n// - Disease progression status (improving, stable, deteriorating, critical)\n// - Clinical indicators (vital signs trends, lab values, functional status)\n// - Full version history to track prognosis changes over time\n// - Links to patient records and specific diagnoses\n// - HIPAA-compliant audit fields\n// ============================================================================\n\n/**\n * Prognosis Tracking - Comprehensive prognosis records with temporal tracking\n * Supports versioning/history to track how prognosis changes over time\n */\nexport const prognosis_tracking = pgTable('prognosis_tracking', {\n  id: bigint('id', { mode: 'number' }).primaryKey().generatedByDefaultAsIdentity(),\n  patient_id: bigint('patient_id', { mode: 'number' }).references(() => patients.id).notNull(),\n\n  // =========================================\n  // VERSION CONTROL\n  // =========================================\n  version: integer('version').default(1).notNull(),\n  is_current: boolean('is_current').default(true).notNull(),\n  previous_version_id: bigint('previous_version_id', { mode: 'number' }),\n  superseded_at: timestamp('superseded_at'),\n  superseded_by_id: text('superseded_by_id').references(() => users.id),\n  superseded_reason: text('superseded_reason'),\n\n  // =========================================\n  // PROGNOSIS STATUS\n  // =========================================\n  prognosis_status: varchar('prognosis_status', { length: 50 }).default('ACTIVE').notNull(),\n  // ACTIVE, UNDER_REVIEW, PROVISIONAL, FINALIZED, AMENDED, ARCHIVED\n\n  // =========================================\n  // EXPECTED LENGTH OF STAY\n  // =========================================\n  admission_date: date('admission_date'),\n  expected_discharge_date: date('expected_discharge_date'),\n  expected_length_of_stay_days: integer('expected_length_of_stay_days'),\n  length_of_stay_range_min_days: integer('length_of_stay_range_min_days'),\n  length_of_stay_range_max_days: integer('length_of_stay_range_max_days'),\n  length_of_stay_confidence_level: varchar('length_of_stay_confidence_level', { length: 50 }),\n  // HIGH, MODERATE, LOW, UNCERTAIN\n  length_of_stay_notes: text('length_of_stay_notes'),\n\n  // Hospice-specific prognosis fields\n  prognosis_months: integer('prognosis_months'),\n  prognosis_less_than_6_months: boolean('prognosis_less_than_6_months'),\n  terminal_diagnosis_confirmed: boolean('terminal_diagnosis_confirmed'),\n  terminal_diagnosis_date: date('terminal_diagnosis_date'),\n\n  // =========================================\n  // DISEASE PROGRESSION STATUS\n  // =========================================\n  disease_progression_status: varchar('disease_progression_status', { length: 50 }).notNull(),\n  // IMPROVING, STABLE, SLOWLY_DECLINING, RAPIDLY_DECLINING, DETERIORATING, CRITICAL, ACTIVELY_DYING\n  disease_progression_trend: varchar('disease_progression_trend', { length: 50 }),\n  // UPWARD, STABLE, DOWNWARD, FLUCTUATING, UNKNOWN\n  progression_rate: varchar('progression_rate', { length: 50 }),\n  // SLOW, MODERATE, RAPID, VERY_RAPID\n  progression_since_last_assessment: varchar('progression_since_last_assessment', { length: 50 }),\n  // SIGNIFICANTLY_BETTER, SLIGHTLY_BETTER, STABLE, SLIGHTLY_WORSE, SIGNIFICANTLY_WORSE\n  disease_progression_notes: text('disease_progression_notes'),\n\n  // =========================================\n  // CLINICAL INDICATORS\n  // =========================================\n  // Vital Signs Trends (summary from vital_signs table)\n  vital_signs_trend: varchar('vital_signs_trend', { length: 50 }),\n  // STABLE, DETERIORATING, IMPROVING, FLUCTUATING\n  vital_signs_summary: jsonb('vital_signs_summary'),\n  // {bp_trend, hr_trend, rr_trend, temp_trend, spo2_trend, pain_trend}\n  vital_signs_last_assessment_date: timestamp('vital_signs_last_assessment_date'),\n\n  // Lab Values\n  lab_values_summary: jsonb('lab_values_summary'),\n  // Array of {test_name, value, unit, trend, date, is_abnormal, clinical_significance}\n  lab_values_trend: varchar('lab_values_trend', { length: 50 }),\n  lab_values_last_date: date('lab_values_last_date'),\n\n  // Functional Status Scores\n  functional_status_score: integer('functional_status_score'),\n  // 0-100 scale or specific scale value\n  functional_status_scale: varchar('functional_status_scale', { length: 50 }),\n  // PPS (Palliative Performance Scale), KPS (Karnofsky), ECOG, ADL, IADL\n  functional_status_trend: varchar('functional_status_trend', { length: 50 }),\n  // IMPROVING, STABLE, DECLINING\n  previous_functional_score: integer('previous_functional_score'),\n  functional_status_date: date('functional_status_date'),\n  functional_status_notes: text('functional_status_notes'),\n\n  // Palliative Performance Scale (PPS) specific fields\n  pps_ambulation: varchar('pps_ambulation', { length: 100 }),\n  // FULL, REDUCED, MAINLY_SIT_LIE, MAINLY_IN_BED, TOTALLY_BEDBOUND\n  pps_activity_evidence_of_disease: varchar('pps_activity_evidence_of_disease', { length: 100 }),\n  pps_self_care: varchar('pps_self_care', { length: 100 }),\n  // FULL, OCCASIONAL_ASSISTANCE, CONSIDERABLE_ASSISTANCE, MAINLY_ASSISTANCE, TOTAL_CARE\n  pps_intake: varchar('pps_intake', { length: 100 }),\n  // NORMAL, REDUCED, MINIMAL, MOUTH_CARE_ONLY\n  pps_conscious_level: varchar('pps_conscious_level', { length: 100 }),\n  // FULL, FULL_OR_CONFUSION, FULL_OR_DROWSY, DROWSY_OR_COMA, COMA\n\n  // =========================================\n  // DIAGNOSIS INFORMATION\n  // =========================================\n  primary_diagnosis_icd10: varchar('primary_diagnosis_icd10', { length: 20 }),\n  primary_diagnosis_description: text('primary_diagnosis_description'),\n  secondary_diagnoses: jsonb('secondary_diagnoses'),\n  // Array of {icd10, description, is_hospice_related, prognosis_impact}\n  comorbidities: jsonb('comorbidities'),\n  // Array of {condition, severity, impact_on_prognosis}\n  diagnosis_related_prognosis_factors: text('diagnosis_related_prognosis_factors'),\n\n  // =========================================\n  // SYMPTOM BURDEN\n  // =========================================\n  symptom_burden_score: integer('symptom_burden_score'),\n  // 0-100 composite score\n  symptom_burden_level: varchar('symptom_burden_level', { length: 50 }),\n  // LOW, MODERATE, HIGH, SEVERE\n  primary_symptoms: jsonb('primary_symptoms'),\n  // Array of {symptom, severity, frequency, impact_on_prognosis}\n  symptom_management_effectiveness: varchar('symptom_management_effectiveness', { length: 50 }),\n  // EXCELLENT, GOOD, FAIR, POOR, REFRACTORY\n\n  // =========================================\n  // IMMINENCE OF DEATH INDICATORS\n  // =========================================\n  is_imminently_dying: boolean('is_imminently_dying').default(false),\n  imminence_level: varchar('imminence_level', { length: 50 }),\n  // MONTHS, WEEKS, DAYS, HOURS\n  imminence_indicators: jsonb('imminence_indicators'),\n  // Array of signs/symptoms indicating imminent death\n  imminence_assessment_date: timestamp('imminence_assessment_date'),\n  days_to_death_estimate: integer('days_to_death_estimate'),\n  hours_to_death_estimate: integer('hours_to_death_estimate'),\n\n  // =========================================\n  // PATIENT/FAMILY AWARENESS\n  // =========================================\n  patient_awareness_of_prognosis: varchar('patient_awareness_of_prognosis', { length: 50 }),\n  // FULLY_AWARE, PARTIALLY_AWARE, UNAWARE, UNCLEAR\n  family_awareness_of_prognosis: varchar('family_awareness_of_prognosis', { length: 50 }),\n  prognosis_discussion_date: date('prognosis_discussion_date'),\n  prognosis_discussed_with: jsonb('prognosis_discussed_with'),\n  // Array of {person, relationship, understanding_level, date}\n  goals_of_care_aligned: boolean('goals_of_care_aligned'),\n  goals_of_care_notes: text('goals_of_care_notes'),\n\n  // =========================================\n  // CONFIDENCE AND UNCERTAINTY\n  // =========================================\n  overall_confidence_level: varchar('overall_confidence_level', { length: 50 }),\n  // HIGH, MODERATE, LOW, VERY_LOW\n  confidence_percentage: integer('confidence_percentage'),\n  // 0-100 percentage\n  uncertainty_factors: jsonb('uncertainty_factors'),\n  // Array of factors contributing to uncertainty\n  prediction_model_used: varchar('prediction_model_used', { length: 100 }),\n  // CLINICAL_JUDGMENT, PPI, SURPRISE_QUESTION, COMBINED\n  surprise_question_response: varchar('surprise_question_response', { length: 50 }),\n  // YES_SURPRISED, NO_NOT_SURPRISED, UNCERTAIN\n\n  // =========================================\n  // COMPLICATIONS\n  // =========================================\n  complications: jsonb('complications'),\n  // Array of {complication, date_occurred, severity, impact_on_prognosis, resolved}\n  unexpected_events: text('unexpected_events'),\n  prognosis_modifying_factors: jsonb('prognosis_modifying_factors'),\n  // Array of factors that could modify prognosis\n\n  // =========================================\n  // REVIEW AND REASSESSMENT\n  // =========================================\n  last_review_date: timestamp('last_review_date'),\n  next_review_date: timestamp('next_review_date'),\n  review_frequency_days: integer('review_frequency_days'),\n  review_notes: text('review_notes'),\n  requires_idg_review: boolean('requires_idg_review').default(false),\n  idg_review_date: date('idg_review_date'),\n  idg_review_outcome: text('idg_review_outcome'),\n\n  // =========================================\n  // CLINICAL NOTES\n  // =========================================\n  clinical_summary: text('clinical_summary'),\n  prognosis_rationale: text('prognosis_rationale'),\n  treatment_response: text('treatment_response'),\n  additional_notes: text('additional_notes'),\n\n  // =========================================\n  // ELECTRONIC SIGNATURE (21 CFR Part 11)\n  // =========================================\n  signature: jsonb('signature'),\n  signed_at: timestamp('signed_at'),\n  signed_by_id: text('signed_by_id').references(() => users.id),\n  cosignature: jsonb('cosignature'),\n  cosigned_at: timestamp('cosigned_at'),\n  cosigned_by_id: text('cosigned_by_id').references(() => users.id),\n  requires_physician_signature: boolean('requires_physician_signature').default(true),\n  physician_signature_date: date('physician_signature_date'),\n\n  // =========================================\n  // AUDIT FIELDS (HIPAA Compliance)\n  // =========================================\n  created_by_id: text('created_by_id').references(() => users.id),\n  updated_by_id: text('updated_by_id').references(() => users.id),\n  deleted_at: timestamp('deleted_at'),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull(),\n}, (table) => ({\n  // Single column indexes\n  patientIdx: index('idx_prognosis_tracking_patient_id').on(table.patient_id),\n  statusIdx: index('idx_prognosis_tracking_status').on(table.prognosis_status),\n  currentIdx: index('idx_prognosis_tracking_is_current').on(table.is_current),\n  progressionIdx: index('idx_prognosis_tracking_progression').on(table.disease_progression_status),\n  imminentIdx: index('idx_prognosis_tracking_imminent').on(table.is_imminently_dying),\n\n  // Composite indexes for common query patterns\n  patientCurrentIdx: index('idx_prognosis_tracking_patient_current').on(table.patient_id, table.is_current),\n  patientVersionIdx: index('idx_prognosis_tracking_patient_version').on(table.patient_id, table.version),\n  patientCreatedIdx: index('idx_prognosis_tracking_patient_created').on(table.patient_id, table.createdAt),\n  progressionTrendIdx: index('idx_prognosis_tracking_progression_trend').on(table.disease_progression_status, table.disease_progression_trend),\n  reviewDateIdx: index('idx_prognosis_tracking_review_date').on(table.next_review_date),\n}));\n\n/**\n * Prognosis History - Audit trail of all prognosis changes\n * Immutable records for compliance and analysis\n */\nexport const prognosis_history = pgTable('prognosis_history', {\n  id: bigint('id', { mode: 'number' }).primaryKey().generatedByDefaultAsIdentity(),\n  prognosis_tracking_id: bigint('prognosis_tracking_id', { mode: 'number' }).references(() => prognosis_tracking.id).notNull(),\n  patient_id: bigint('patient_id', { mode: 'number' }).references(() => patients.id).notNull(),\n\n  // Change tracking\n  change_type: varchar('change_type', { length: 50 }).notNull(),\n  // CREATE, UPDATE, STATUS_CHANGE, PROGRESSION_CHANGE, REVIEW, SIGNATURE, ARCHIVE\n  change_date: timestamp('change_date').defaultNow().notNull(),\n  changed_by_id: text('changed_by_id').references(() => users.id),\n  changed_by_name: varchar('changed_by_name', { length: 255 }),\n  changed_by_role: varchar('changed_by_role', { length: 100 }),\n\n  // Previous and new values\n  field_changed: varchar('field_changed', { length: 100 }),\n  previous_value: text('previous_value'),\n  new_value: text('new_value'),\n  change_reason: text('change_reason'),\n\n  // Snapshot of key fields at time of change\n  snapshot: jsonb('snapshot'),\n  // Complete snapshot of prognosis state at time of change\n\n  // Clinical context\n  clinical_context: text('clinical_context'),\n  triggering_event: varchar('triggering_event', { length: 255 }),\n  // e.g., \"Unexpected complication\", \"IDG review\", \"Routine reassessment\"\n\n  // Audit fields\n  ip_address: varchar('ip_address', { length: 45 }),\n  user_agent: text('user_agent'),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n}, (table) => ({\n  prognosisIdx: index('idx_prognosis_history_prognosis_id').on(table.prognosis_tracking_id),\n  patientIdx: index('idx_prognosis_history_patient_id').on(table.patient_id),\n  changeDateIdx: index('idx_prognosis_history_change_date').on(table.change_date),\n  changeTypeIdx: index('idx_prognosis_history_change_type').on(table.change_type),\n  changedByIdx: index('idx_prognosis_history_changed_by').on(table.changed_by_id),\n  patientDateIdx: index('idx_prognosis_history_patient_date').on(table.patient_id, table.change_date),\n}));\n\n/**\n * Prognosis Clinical Indicators - Detailed clinical indicator tracking\n * Supports trend analysis over time\n */\nexport const prognosis_clinical_indicators = pgTable('prognosis_clinical_indicators', {\n  id: bigint('id', { mode: 'number' }).primaryKey().generatedByDefaultAsIdentity(),\n  prognosis_tracking_id: bigint('prognosis_tracking_id', { mode: 'number' }).references(() => prognosis_tracking.id).notNull(),\n  patient_id: bigint('patient_id', { mode: 'number' }).references(() => patients.id).notNull(),\n\n  // Indicator identification\n  indicator_type: varchar('indicator_type', { length: 50 }).notNull(),\n  // VITAL_SIGN, LAB_VALUE, FUNCTIONAL_SCORE, SYMPTOM, WEIGHT, NUTRITION, COGNITION\n  indicator_name: varchar('indicator_name', { length: 100 }).notNull(),\n  indicator_code: varchar('indicator_code', { length: 50 }),\n  // LOINC, SNOMED, or internal code\n\n  // Measurement\n  measurement_date: timestamp('measurement_date').notNull(),\n  value_numeric: decimal('value_numeric', { precision: 10, scale: 4 }),\n  value_text: varchar('value_text', { length: 255 }),\n  value_unit: varchar('value_unit', { length: 50 }),\n\n  // Reference ranges\n  normal_range_low: decimal('normal_range_low', { precision: 10, scale: 4 }),\n  normal_range_high: decimal('normal_range_high', { precision: 10, scale: 4 }),\n  critical_range_low: decimal('critical_range_low', { precision: 10, scale: 4 }),\n  critical_range_high: decimal('critical_range_high', { precision: 10, scale: 4 }),\n  is_abnormal: boolean('is_abnormal').default(false),\n  is_critical: boolean('is_critical').default(false),\n  abnormality_direction: varchar('abnormality_direction', { length: 20 }),\n  // HIGH, LOW, CRITICAL_HIGH, CRITICAL_LOW\n\n  // Trend analysis\n  trend_direction: varchar('trend_direction', { length: 50 }),\n  // IMPROVING, STABLE, WORSENING, FLUCTUATING\n  trend_rate: varchar('trend_rate', { length: 50 }),\n  // SLOW, MODERATE, RAPID\n  previous_value: decimal('previous_value', { precision: 10, scale: 4 }),\n  change_percentage: decimal('change_percentage', { precision: 6, scale: 2 }),\n  days_since_previous: integer('days_since_previous'),\n\n  // Clinical significance\n  clinical_significance: varchar('clinical_significance', { length: 50 }),\n  // LOW, MODERATE, HIGH, CRITICAL\n  prognosis_impact: varchar('prognosis_impact', { length: 50 }),\n  // POSITIVE, NEUTRAL, NEGATIVE, UNCERTAIN\n  notes: text('notes'),\n\n  // Source\n  source_system: varchar('source_system', { length: 100 }),\n  source_record_id: varchar('source_record_id', { length: 255 }),\n  recorded_by_id: text('recorded_by_id').references(() => users.id),\n\n  // Audit fields\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull(),\n}, (table) => ({\n  prognosisIdx: index('idx_prognosis_indicators_prognosis_id').on(table.prognosis_tracking_id),\n  patientIdx: index('idx_prognosis_indicators_patient_id').on(table.patient_id),\n  typeIdx: index('idx_prognosis_indicators_type').on(table.indicator_type),\n  dateIdx: index('idx_prognosis_indicators_date').on(table.measurement_date),\n  abnormalIdx: index('idx_prognosis_indicators_abnormal').on(table.is_abnormal),\n  criticalIdx: index('idx_prognosis_indicators_critical').on(table.is_critical),\n  patientTypeDateIdx: index('idx_prognosis_indicators_patient_type_date').on(table.patient_id, table.indicator_type, table.measurement_date),\n}));\n\n/**\n * Prognosis Outcome Tracking - For retrospective analysis\n * Links prognoses to actual outcomes for quality improvement\n */\nexport const prognosis_outcomes = pgTable('prognosis_outcomes', {\n  id: bigint('id', { mode: 'number' }).primaryKey().generatedByDefaultAsIdentity(),\n  prognosis_tracking_id: bigint('prognosis_tracking_id', { mode: 'number' }).references(() => prognosis_tracking.id).notNull(),\n  patient_id: bigint('patient_id', { mode: 'number' }).references(() => patients.id).notNull(),\n\n  // Outcome details\n  outcome_type: varchar('outcome_type', { length: 50 }).notNull(),\n  // DEATH, DISCHARGE_ALIVE, TRANSFER, REVOCATION, ONGOING\n  outcome_date: date('outcome_date'),\n  outcome_location: varchar('outcome_location', { length: 100 }),\n  // HOME, HOSPITAL, FACILITY, OTHER\n\n  // Prognosis accuracy analysis\n  prognosis_date: date('prognosis_date').notNull(),\n  predicted_los_days: integer('predicted_los_days'),\n  actual_los_days: integer('actual_los_days'),\n  los_variance_days: integer('los_variance_days'),\n  los_accuracy_category: varchar('los_accuracy_category', { length: 50 }),\n  // ACCURATE, UNDERESTIMATED, OVERESTIMATED\n\n  predicted_imminence_level: varchar('predicted_imminence_level', { length: 50 }),\n  actual_time_to_outcome_days: integer('actual_time_to_outcome_days'),\n  imminence_accuracy_category: varchar('imminence_accuracy_category', { length: 50 }),\n\n  // Quality metrics\n  symptom_management_at_end: varchar('symptom_management_at_end', { length: 50 }),\n  // EXCELLENT, GOOD, FAIR, POOR\n  family_satisfaction: varchar('family_satisfaction', { length: 50 }),\n  goals_achieved: boolean('goals_achieved'),\n  unexpected_events_occurred: boolean('unexpected_events_occurred'),\n  unexpected_events_description: text('unexpected_events_description'),\n\n  // Analysis notes\n  analysis_notes: text('analysis_notes'),\n  lessons_learned: text('lessons_learned'),\n  analyzed_by_id: text('analyzed_by_id').references(() => users.id),\n  analysis_date: timestamp('analysis_date'),\n\n  // Audit fields\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull(),\n}, (table) => ({\n  prognosisIdx: index('idx_prognosis_outcomes_prognosis_id').on(table.prognosis_tracking_id),\n  patientIdx: index('idx_prognosis_outcomes_patient_id').on(table.patient_id),\n  outcomeTypeIdx: index('idx_prognosis_outcomes_type').on(table.outcome_type),\n  outcomeDateIdx: index('idx_prognosis_outcomes_date').on(table.outcome_date),\n  accuracyIdx: index('idx_prognosis_outcomes_accuracy').on(table.los_accuracy_category),\n}));\n\n// ============================================================================\n// ENUMS AND CONSTANTS\n// ============================================================================\n\n// Disease Progression Status\nexport const DISEASE_PROGRESSION_STATUS = {\n  IMPROVING: 'IMPROVING',\n  STABLE: 'STABLE',\n  SLOWLY_DECLINING: 'SLOWLY_DECLINING',\n  RAPIDLY_DECLINING: 'RAPIDLY_DECLINING',\n  DETERIORATING: 'DETERIORATING',\n  CRITICAL: 'CRITICAL',\n  ACTIVELY_DYING: 'ACTIVELY_DYING',\n};\n\n// Progression Trend\nexport const PROGRESSION_TREND = {\n  UPWARD: 'UPWARD',\n  STABLE: 'STABLE',\n  DOWNWARD: 'DOWNWARD',\n  FLUCTUATING: 'FLUCTUATING',\n  UNKNOWN: 'UNKNOWN',\n};\n\n// Prognosis Status\nexport const PROGNOSIS_STATUS = {\n  ACTIVE: 'ACTIVE',\n  UNDER_REVIEW: 'UNDER_REVIEW',\n  PROVISIONAL: 'PROVISIONAL',\n  FINALIZED: 'FINALIZED',\n  AMENDED: 'AMENDED',\n  ARCHIVED: 'ARCHIVED',\n};\n\n// Confidence Levels\nexport const CONFIDENCE_LEVELS = {\n  HIGH: 'HIGH',\n  MODERATE: 'MODERATE',\n  LOW: 'LOW',\n  VERY_LOW: 'VERY_LOW',\n};\n\n// Imminence Levels\nexport const IMMINENCE_LEVELS = {\n  MONTHS: 'MONTHS',\n  WEEKS: 'WEEKS',\n  DAYS: 'DAYS',\n  HOURS: 'HOURS',\n};\n\n// Functional Status Scales\nexport const FUNCTIONAL_STATUS_SCALES = {\n  PPS: 'PPS', // Palliative Performance Scale\n  KPS: 'KPS', // Karnofsky Performance Status\n  ECOG: 'ECOG', // Eastern Cooperative Oncology Group\n  ADL: 'ADL', // Activities of Daily Living\n  IADL: 'IADL', // Instrumental Activities of Daily Living\n};\n\n// Clinical Indicator Types\nexport const CLINICAL_INDICATOR_TYPES = {\n  VITAL_SIGN: 'VITAL_SIGN',\n  LAB_VALUE: 'LAB_VALUE',\n  FUNCTIONAL_SCORE: 'FUNCTIONAL_SCORE',\n  SYMPTOM: 'SYMPTOM',\n  WEIGHT: 'WEIGHT',\n  NUTRITION: 'NUTRITION',\n  COGNITION: 'COGNITION',\n};\n\n// PPS Score Mapping (Palliative Performance Scale)\nexport const PPS_SCORES = {\n  100: { ambulation: 'FULL', activity: 'NORMAL', self_care: 'FULL', intake: 'NORMAL', conscious: 'FULL' },\n  90: { ambulation: 'FULL', activity: 'NORMAL_WITH_EFFORT', self_care: 'FULL', intake: 'NORMAL', conscious: 'FULL' },\n  80: { ambulation: 'FULL', activity: 'WITH_EFFORT', self_care: 'FULL', intake: 'NORMAL_OR_REDUCED', conscious: 'FULL' },\n  70: { ambulation: 'REDUCED', activity: 'UNABLE_TO_DO_WORK', self_care: 'FULL', intake: 'NORMAL_OR_REDUCED', conscious: 'FULL' },\n  60: { ambulation: 'REDUCED', activity: 'UNABLE_TO_DO_HOBBIES', self_care: 'OCCASIONAL_ASSISTANCE', intake: 'NORMAL_OR_REDUCED', conscious: 'FULL_OR_CONFUSION' },\n  50: { ambulation: 'MAINLY_SIT_LIE', activity: 'UNABLE_TO_DO_ANY', self_care: 'CONSIDERABLE_ASSISTANCE', intake: 'NORMAL_OR_REDUCED', conscious: 'FULL_OR_CONFUSION' },\n  40: { ambulation: 'MAINLY_IN_BED', activity: 'UNABLE_TO_DO_ANY', self_care: 'MAINLY_ASSISTANCE', intake: 'NORMAL_OR_REDUCED', conscious: 'FULL_OR_DROWSY' },\n  30: { ambulation: 'TOTALLY_BEDBOUND', activity: 'UNABLE_TO_DO_ANY', self_care: 'TOTAL_CARE', intake: 'REDUCED', conscious: 'FULL_OR_DROWSY' },\n  20: { ambulation: 'TOTALLY_BEDBOUND', activity: 'UNABLE_TO_DO_ANY', self_care: 'TOTAL_CARE', intake: 'MINIMAL', conscious: 'FULL_OR_DROWSY' },\n  10: { ambulation: 'TOTALLY_BEDBOUND', activity: 'UNABLE_TO_DO_ANY', self_care: 'TOTAL_CARE', intake: 'MOUTH_CARE', conscious: 'DROWSY_OR_COMA' },\n  0: { ambulation: 'DEATH', activity: 'DEATH', self_care: 'DEATH', intake: 'DEATH', conscious: 'DEATH' },\n};\n"
}

ðŸ”§ Tool: TodoWrite
Input: {
  "todos": [
    {
      "content": "Explore existing codebase structure and patterns",
      "status": "completed",
      "activeForm": "Exploring existing codebase structure and patterns"
    },
    {
      "content": "Create comprehensive prognosis tracking schema",
      "status": "completed",
      "activeForm": "Creating comprehensive prognosis tracking schema"
    },
    {
      "content": "Create database migration",
      "status": "in_progress",
      "activeForm": "Creating database migration"
    },
    {
      "content": "Add schema to index exports",
      "status": "pending",
      "activeForm": "Adding schema to index exports"
    },
    {
      "content": "Update prognosis controller with new functionality",
      "status": "pending",
      "activeForm": "Updating prognosis controller with new functionality"
    },
    {
      "content": "Update prognosis routes",
      "status": "pending",
      "activeForm": "Updating prognosis routes"
    },
    {
      "content": "Verify implementation with Playwright test",
      "status": "pending",
      "activeForm": "Verifying implementation with Playwright test"
    }
  ]
}

Now let me create the database migration file.

ðŸ”§ Tool: Write
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/database/migrations/drizzle/0043_prognosis_tracking_schema.sql",
  "content": "-- Migration: 0043_prognosis_tracking_schema\n-- Description: Comprehensive Prognosis Tracking Schema for Hospice Care\n--\n-- This migration creates tables for tracking patient prognosis information including:\n-- - Expected length of stay with date ranges\n-- - Disease progression status tracking\n-- - Clinical indicators with trend analysis\n-- - Full version history for audit compliance\n-- - Outcome tracking for quality improvement\n--\n-- HIPAA Compliance: All tables include audit fields for tracking access and changes\n\n-- ============================================================================\n-- PROGNOSIS TRACKING - Main Table\n-- ============================================================================\n-- Comprehensive prognosis records with temporal tracking and versioning\nCREATE TABLE IF NOT EXISTS prognosis_tracking (\n    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,\n    patient_id BIGINT NOT NULL REFERENCES patients(id),\n\n    -- Version Control\n    version INTEGER NOT NULL DEFAULT 1,\n    is_current BOOLEAN NOT NULL DEFAULT true,\n    previous_version_id BIGINT,\n    superseded_at TIMESTAMP,\n    superseded_by_id TEXT REFERENCES \"user\"(id),\n    superseded_reason TEXT,\n\n    -- Prognosis Status\n    prognosis_status VARCHAR(50) NOT NULL DEFAULT 'ACTIVE',\n    -- ACTIVE, UNDER_REVIEW, PROVISIONAL, FINALIZED, AMENDED, ARCHIVED\n\n    -- Expected Length of Stay\n    admission_date DATE,\n    expected_discharge_date DATE,\n    expected_length_of_stay_days INTEGER,\n    length_of_stay_range_min_days INTEGER,\n    length_of_stay_range_max_days INTEGER,\n    length_of_stay_confidence_level VARCHAR(50),\n    length_of_stay_notes TEXT,\n\n    -- Hospice-specific prognosis fields\n    prognosis_months INTEGER,\n    prognosis_less_than_6_months BOOLEAN,\n    terminal_diagnosis_confirmed BOOLEAN,\n    terminal_diagnosis_date DATE,\n\n    -- Disease Progression Status\n    disease_progression_status VARCHAR(50) NOT NULL,\n    -- IMPROVING, STABLE, SLOWLY_DECLINING, RAPIDLY_DECLINING, DETERIORATING, CRITICAL, ACTIVELY_DYING\n    disease_progression_trend VARCHAR(50),\n    progression_rate VARCHAR(50),\n    progression_since_last_assessment VARCHAR(50),\n    disease_progression_notes TEXT,\n\n    -- Clinical Indicators - Vital Signs\n    vital_signs_trend VARCHAR(50),\n    vital_signs_summary JSONB,\n    vital_signs_last_assessment_date TIMESTAMP,\n\n    -- Clinical Indicators - Lab Values\n    lab_values_summary JSONB,\n    lab_values_trend VARCHAR(50),\n    lab_values_last_date DATE,\n\n    -- Clinical Indicators - Functional Status\n    functional_status_score INTEGER,\n    functional_status_scale VARCHAR(50),\n    functional_status_trend VARCHAR(50),\n    previous_functional_score INTEGER,\n    functional_status_date DATE,\n    functional_status_notes TEXT,\n\n    -- PPS (Palliative Performance Scale) fields\n    pps_ambulation VARCHAR(100),\n    pps_activity_evidence_of_disease VARCHAR(100),\n    pps_self_care VARCHAR(100),\n    pps_intake VARCHAR(100),\n    pps_conscious_level VARCHAR(100),\n\n    -- Diagnosis Information\n    primary_diagnosis_icd10 VARCHAR(20),\n    primary_diagnosis_description TEXT,\n    secondary_diagnoses JSONB,\n    comorbidities JSONB,\n    diagnosis_related_prognosis_factors TEXT,\n\n    -- Symptom Burden\n    symptom_burden_score INTEGER,\n    symptom_burden_level VARCHAR(50),\n    primary_symptoms JSONB,\n    symptom_management_effectiveness VARCHAR(50),\n\n    -- Imminence of Death Indicators\n    is_imminently_dying BOOLEAN DEFAULT false,\n    imminence_level VARCHAR(50),\n    imminence_indicators JSONB,\n    imminence_assessment_date TIMESTAMP,\n    days_to_death_estimate INTEGER,\n    hours_to_death_estimate INTEGER,\n\n    -- Patient/Family Awareness\n    patient_awareness_of_prognosis VARCHAR(50),\n    family_awareness_of_prognosis VARCHAR(50),\n    prognosis_discussion_date DATE,\n    prognosis_discussed_with JSONB,\n    goals_of_care_aligned BOOLEAN,\n    goals_of_care_notes TEXT,\n\n    -- Confidence and Uncertainty\n    overall_confidence_level VARCHAR(50),\n    confidence_percentage INTEGER,\n    uncertainty_factors JSONB,\n    prediction_model_used VARCHAR(100),\n    surprise_question_response VARCHAR(50),\n\n    -- Complications\n    complications JSONB,\n    unexpected_events TEXT,\n    prognosis_modifying_factors JSONB,\n\n    -- Review and Reassessment\n    last_review_date TIMESTAMP,\n    next_review_date TIMESTAMP,\n    review_frequency_days INTEGER,\n    review_notes TEXT,\n    requires_idg_review BOOLEAN DEFAULT false,\n    idg_review_date DATE,\n    idg_review_outcome TEXT,\n\n    -- Clinical Notes\n    clinical_summary TEXT,\n    prognosis_rationale TEXT,\n    treatment_response TEXT,\n    additional_notes TEXT,\n\n    -- Electronic Signature (21 CFR Part 11)\n    signature JSONB,\n    signed_at TIMESTAMP,\n    signed_by_id TEXT REFERENCES \"user\"(id),\n    cosignature JSONB,\n    cosigned_at TIMESTAMP,\n    cosigned_by_id TEXT REFERENCES \"user\"(id),\n    requires_physician_signature BOOLEAN DEFAULT true,\n    physician_signature_date DATE,\n\n    -- Audit Fields (HIPAA Compliance)\n    created_by_id TEXT REFERENCES \"user\"(id),\n    updated_by_id TEXT REFERENCES \"user\"(id),\n    deleted_at TIMESTAMP,\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMP NOT NULL DEFAULT NOW()\n);\n\n-- Self-reference for version history\nALTER TABLE prognosis_tracking\nADD CONSTRAINT fk_prognosis_tracking_previous_version\nFOREIGN KEY (previous_version_id) REFERENCES prognosis_tracking(id);\n\n-- Indexes for prognosis_tracking\nCREATE INDEX IF NOT EXISTS idx_prognosis_tracking_patient_id ON prognosis_tracking(patient_id);\nCREATE INDEX IF NOT EXISTS idx_prognosis_tracking_status ON prognosis_tracking(prognosis_status);\nCREATE INDEX IF NOT EXISTS idx_prognosis_tracking_is_current ON prognosis_tracking(is_current);\nCREATE INDEX IF NOT EXISTS idx_prognosis_tracking_progression ON prognosis_tracking(disease_progression_status);\nCREATE INDEX IF NOT EXISTS idx_prognosis_tracking_imminent ON prognosis_tracking(is_imminently_dying);\nCREATE INDEX IF NOT EXISTS idx_prognosis_tracking_patient_current ON prognosis_tracking(patient_id, is_current);\nCREATE INDEX IF NOT EXISTS idx_prognosis_tracking_patient_version ON prognosis_tracking(patient_id, version);\nCREATE INDEX IF NOT EXISTS idx_prognosis_tracking_patient_created ON prognosis_tracking(patient_id, created_at);\nCREATE INDEX IF NOT EXISTS idx_prognosis_tracking_progression_trend ON prognosis_tracking(disease_progression_status, disease_progression_trend);\nCREATE INDEX IF NOT EXISTS idx_prognosis_tracking_review_date ON prognosis_tracking(next_review_date);\n\n-- ============================================================================\n-- PROGNOSIS HISTORY - Audit Trail\n-- ============================================================================\n-- Immutable records for compliance and analysis\nCREATE TABLE IF NOT EXISTS prognosis_history (\n    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,\n    prognosis_tracking_id BIGINT NOT NULL REFERENCES prognosis_tracking(id),\n    patient_id BIGINT NOT NULL REFERENCES patients(id),\n\n    -- Change tracking\n    change_type VARCHAR(50) NOT NULL,\n    -- CREATE, UPDATE, STATUS_CHANGE, PROGRESSION_CHANGE, REVIEW, SIGNATURE, ARCHIVE\n    change_date TIMESTAMP NOT NULL DEFAULT NOW(),\n    changed_by_id TEXT REFERENCES \"user\"(id),\n    changed_by_name VARCHAR(255),\n    changed_by_role VARCHAR(100),\n\n    -- Previous and new values\n    field_changed VARCHAR(100),\n    previous_value TEXT,\n    new_value TEXT,\n    change_reason TEXT,\n\n    -- Snapshot\n    snapshot JSONB,\n\n    -- Clinical context\n    clinical_context TEXT,\n    triggering_event VARCHAR(255),\n\n    -- Audit fields\n    ip_address VARCHAR(45),\n    user_agent TEXT,\n    created_at TIMESTAMP NOT NULL DEFAULT NOW()\n);\n\n-- Indexes for prognosis_history\nCREATE INDEX IF NOT EXISTS idx_prognosis_history_prognosis_id ON prognosis_history(prognosis_tracking_id);\nCREATE INDEX IF NOT EXISTS idx_prognosis_history_patient_id ON prognosis_history(patient_id);\nCREATE INDEX IF NOT EXISTS idx_prognosis_history_change_date ON prognosis_history(change_date);\nCREATE INDEX IF NOT EXISTS idx_prognosis_history_change_type ON prognosis_history(change_type);\nCREATE INDEX IF NOT EXISTS idx_prognosis_history_changed_by ON prognosis_history(changed_by_id);\nCREATE INDEX IF NOT EXISTS idx_prognosis_history_patient_date ON prognosis_history(patient_id, change_date);\n\n-- ============================================================================\n-- PROGNOSIS CLINICAL INDICATORS - Detailed Tracking\n-- ============================================================================\n-- Supports trend analysis over time\nCREATE TABLE IF NOT EXISTS prognosis_clinical_indicators (\n    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,\n    prognosis_tracking_id BIGINT NOT NULL REFERENCES prognosis_tracking(id),\n    patient_id BIGINT NOT NULL REFERENCES patients(id),\n\n    -- Indicator identification\n    indicator_type VARCHAR(50) NOT NULL,\n    -- VITAL_SIGN, LAB_VALUE, FUNCTIONAL_SCORE, SYMPTOM, WEIGHT, NUTRITION, COGNITION\n    indicator_name VARCHAR(100) NOT NULL,\n    indicator_code VARCHAR(50),\n\n    -- Measurement\n    measurement_date TIMESTAMP NOT NULL,\n    value_numeric DECIMAL(10, 4),\n    value_text VARCHAR(255),\n    value_unit VARCHAR(50),\n\n    -- Reference ranges\n    normal_range_low DECIMAL(10, 4),\n    normal_range_high DECIMAL(10, 4),\n    critical_range_low DECIMAL(10, 4),\n    critical_range_high DECIMAL(10, 4),\n    is_abnormal BOOLEAN DEFAULT false,\n    is_critical BOOLEAN DEFAULT false,\n    abnormality_direction VARCHAR(20),\n\n    -- Trend analysis\n    trend_direction VARCHAR(50),\n    trend_rate VARCHAR(50),\n    previous_value DECIMAL(10, 4),\n    change_percentage DECIMAL(6, 2),\n    days_since_previous INTEGER,\n\n    -- Clinical significance\n    clinical_significance VARCHAR(50),\n    prognosis_impact VARCHAR(50),\n    notes TEXT,\n\n    -- Source\n    source_system VARCHAR(100),\n    source_record_id VARCHAR(255),\n    recorded_by_id TEXT REFERENCES \"user\"(id),\n\n    -- Audit fields\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMP NOT NULL DEFAULT NOW()\n);\n\n-- Indexes for prognosis_clinical_indicators\nCREATE INDEX IF NOT EXISTS idx_prognosis_indicators_prognosis_id ON prognosis_clinical_indicators(prognosis_tracking_id);\nCREATE INDEX IF NOT EXISTS idx_prognosis_indicators_patient_id ON prognosis_clinical_indicators(patient_id);\nCREATE INDEX IF NOT EXISTS idx_prognosis_indicators_type ON prognosis_clinical_indicators(indicator_type);\nCREATE INDEX IF NOT EXISTS idx_prognosis_indicators_date ON prognosis_clinical_indicators(measurement_date);\nCREATE INDEX IF NOT EXISTS idx_prognosis_indicators_abnormal ON prognosis_clinical_indicators(is_abnormal);\nCREATE INDEX IF NOT EXISTS idx_prognosis_indicators_critical ON prognosis_clinical_indicators(is_critical);\nCREATE INDEX IF NOT EXISTS idx_prognosis_indicators_patient_type_date ON prognosis_clinical_indicators(patient_id, indicator_type, measurement_date);\n\n-- ============================================================================\n-- PROGNOSIS OUTCOMES - Retrospective Analysis\n-- ============================================================================\n-- Links prognoses to actual outcomes for quality improvement\nCREATE TABLE IF NOT EXISTS prognosis_outcomes (\n    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,\n    prognosis_tracking_id BIGINT NOT NULL REFERENCES prognosis_tracking(id),\n    patient_id BIGINT NOT NULL REFERENCES patients(id),\n\n    -- Outcome details\n    outcome_type VARCHAR(50) NOT NULL,\n    -- DEATH, DISCHARGE_ALIVE, TRANSFER, REVOCATION, ONGOING\n    outcome_date DATE,\n    outcome_location VARCHAR(100),\n\n    -- Prognosis accuracy analysis\n    prognosis_date DATE NOT NULL,\n    predicted_los_days INTEGER,\n    actual_los_days INTEGER,\n    los_variance_days INTEGER,\n    los_accuracy_category VARCHAR(50),\n\n    predicted_imminence_level VARCHAR(50),\n    actual_time_to_outcome_days INTEGER,\n    imminence_accuracy_category VARCHAR(50),\n\n    -- Quality metrics\n    symptom_management_at_end VARCHAR(50),\n    family_satisfaction VARCHAR(50),\n    goals_achieved BOOLEAN,\n    unexpected_events_occurred BOOLEAN,\n    unexpected_events_description TEXT,\n\n    -- Analysis notes\n    analysis_notes TEXT,\n    lessons_learned TEXT,\n    analyzed_by_id TEXT REFERENCES \"user\"(id),\n    analysis_date TIMESTAMP,\n\n    -- Audit fields\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMP NOT NULL DEFAULT NOW()\n);\n\n-- Indexes for prognosis_outcomes\nCREATE INDEX IF NOT EXISTS idx_prognosis_outcomes_prognosis_id ON prognosis_outcomes(prognosis_tracking_id);\nCREATE INDEX IF NOT EXISTS idx_prognosis_outcomes_patient_id ON prognosis_outcomes(patient_id);\nCREATE INDEX IF NOT EXISTS idx_prognosis_outcomes_type ON prognosis_outcomes(outcome_type);\nCREATE INDEX IF NOT EXISTS idx_prognosis_outcomes_date ON prognosis_outcomes(outcome_date);\nCREATE INDEX IF NOT EXISTS idx_prognosis_outcomes_accuracy ON prognosis_outcomes(los_accuracy_category);\n\n-- ============================================================================\n-- COMMENTS FOR DOCUMENTATION\n-- ============================================================================\nCOMMENT ON TABLE prognosis_tracking IS 'Comprehensive prognosis tracking with version control and temporal tracking capabilities for hospice patients';\nCOMMENT ON TABLE prognosis_history IS 'Immutable audit trail of all prognosis changes for HIPAA compliance and retrospective analysis';\nCOMMENT ON TABLE prognosis_clinical_indicators IS 'Detailed clinical indicator tracking with trend analysis for prognosis assessment';\nCOMMENT ON TABLE prognosis_outcomes IS 'Outcome tracking for retrospective analysis and quality improvement of prognosis predictions';\n\nCOMMENT ON COLUMN prognosis_tracking.disease_progression_status IS 'Current disease progression status: IMPROVING, STABLE, SLOWLY_DECLINING, RAPIDLY_DECLINING, DETERIORATING, CRITICAL, ACTIVELY_DYING';\nCOMMENT ON COLUMN prognosis_tracking.is_current IS 'Indicates if this is the current active prognosis record for the patient (only one per patient should be true)';\nCOMMENT ON COLUMN prognosis_tracking.functional_status_scale IS 'Scale used for functional assessment: PPS (Palliative Performance Scale), KPS (Karnofsky), ECOG, ADL, IADL';\nCOMMENT ON COLUMN prognosis_tracking.imminence_level IS 'Estimated time until death: MONTHS, WEEKS, DAYS, HOURS';\nCOMMENT ON COLUMN prognosis_tracking.surprise_question_response IS 'Response to \"Would you be surprised if this patient died in the next year?\": YES_SURPRISED, NO_NOT_SURPRISED, UNCERTAIN';\n"
}

ðŸ”§ Tool: TodoWrite
Input: {
  "todos": [
    {
      "content": "Explore existing codebase structure and patterns",
      "status": "completed",
      "activeForm": "Exploring existing codebase structure and patterns"
    },
    {
      "content": "Create comprehensive prognosis tracking schema",
      "status": "completed",
      "activeForm": "Creating comprehensive prognosis tracking schema"
    },
    {
      "content": "Create database migration",
      "status": "completed",
      "activeForm": "Creating database migration"
    },
    {
      "content": "Add schema to index exports",
      "status": "in_progress",
      "activeForm": "Adding schema to index exports"
    },
    {
      "content": "Update prognosis controller with new functionality",
      "status": "pending",
      "activeForm": "Updating prognosis controller with new functionality"
    },
    {
      "content": "Update prognosis routes",
      "status": "pending",
      "activeForm": "Updating prognosis routes"
    },
    {
      "content": "Verify implementation with Playwright test",
      "status": "pending",
      "activeForm": "Verifying implementation with Playwright test"
    }
  ]
}

Now let me add the new schema to the index exports.

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/index.js"
}

ðŸ”§ Tool: Edit
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/index.js",
  "old_string": "export * from './prognosisPatient.schema.js';\nexport * from './raceEthnicity.schema.js';",
  "new_string": "export * from './prognosisPatient.schema.js';\nexport * from './prognosisTracking.schema.js';\nexport * from './raceEthnicity.schema.js';"
}

ðŸ”§ Tool: TodoWrite
Input: {
  "todos": [
    {
      "content": "Explore existing codebase structure and patterns",
      "status": "completed",
      "activeForm": "Exploring existing codebase structure and patterns"
    },
    {
      "content": "Create comprehensive prognosis tracking schema",
      "status": "completed",
      "activeForm": "Creating comprehensive prognosis tracking schema"
    },
    {
      "content": "Create database migration",
      "status": "completed",
      "activeForm": "Creating database migration"
    },
    {
      "content": "Add schema to index exports",
      "status": "completed",
      "activeForm": "Adding schema to index exports"
    },
    {
      "content": "Create prognosis tracking controller",
      "status": "in_progress",
      "activeForm": "Creating prognosis tracking controller"
    },
    {
      "content": "Create prognosis tracking routes",
      "status": "pending",
      "activeForm": "Creating prognosis tracking routes"
    },
    {
      "content": "Register routes in API",
      "status": "pending",
      "activeForm": "Registering routes in API"
    },
    {
      "content": "Verify implementation with Playwright test",
      "status": "pending",
      "activeForm": "Verifying implementation with Playwright test"
    }
  ]
}

Now let me create a comprehensive controller for the prognosis tracking functionality.

ðŸ”§ Tool: Write
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/controllers/PrognosisTracking.controller.js",
  "content": "import { db } from \"../config/db.drizzle.js\";\nimport {\n  prognosis_tracking,\n  prognosis_history,\n  prognosis_clinical_indicators,\n  prognosis_outcomes,\n  DISEASE_PROGRESSION_STATUS,\n  PROGNOSIS_STATUS,\n  CONFIDENCE_LEVELS,\n  IMMINENCE_LEVELS,\n  FUNCTIONAL_STATUS_SCALES,\n  CLINICAL_INDICATOR_TYPES,\n} from \"../db/schemas/prognosisTracking.schema.js\";\nimport { patients } from \"../db/schemas/patient.schema.js\";\nimport { eq, and, desc, sql, isNull } from \"drizzle-orm\";\nimport { logger } from '../utils/logger.js';\n\n/**\n * PrognosisTracking Controller\n * Handles comprehensive prognosis tracking for hospice patients\n * Includes versioning, clinical indicators, and outcome tracking\n */\nclass PrognosisTrackingController {\n  /**\n   * Get all prognosis tracking records with optional filters\n   * GET /prognosis-tracking\n   */\n  async index(request, reply) {\n    try {\n      const {\n        patient_id,\n        status,\n        progression_status,\n        is_current,\n        is_imminently_dying,\n        limit = 50,\n        offset = 0,\n      } = request.query;\n\n      let query = db\n        .select()\n        .from(prognosis_tracking)\n        .where(isNull(prognosis_tracking.deleted_at))\n        .orderBy(desc(prognosis_tracking.createdAt))\n        .limit(parseInt(limit))\n        .offset(parseInt(offset));\n\n      // Apply filters\n      const conditions = [isNull(prognosis_tracking.deleted_at)];\n\n      if (patient_id) {\n        conditions.push(eq(prognosis_tracking.patient_id, parseInt(patient_id)));\n      }\n      if (status) {\n        conditions.push(eq(prognosis_tracking.prognosis_status, status));\n      }\n      if (progression_status) {\n        conditions.push(eq(prognosis_tracking.disease_progression_status, progression_status));\n      }\n      if (is_current !== undefined) {\n        conditions.push(eq(prognosis_tracking.is_current, is_current === 'true'));\n      }\n      if (is_imminently_dying !== undefined) {\n        conditions.push(eq(prognosis_tracking.is_imminently_dying, is_imminently_dying === 'true'));\n      }\n\n      const results = await db\n        .select()\n        .from(prognosis_tracking)\n        .where(and(...conditions))\n        .orderBy(desc(prognosis_tracking.createdAt))\n        .limit(parseInt(limit))\n        .offset(parseInt(offset));\n\n      reply.code(200);\n      return {\n        success: true,\n        data: results,\n        meta: {\n          limit: parseInt(limit),\n          offset: parseInt(offset),\n          count: results.length,\n        },\n      };\n    } catch (error) {\n      logger.error(\"Error fetching prognosis tracking records:\", error);\n      reply.code(500);\n      return {\n        success: false,\n        error: {\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Error fetching prognosis tracking records\",\n        },\n      };\n    }\n  }\n\n  /**\n   * Get current prognosis for a patient\n   * GET /prognosis-tracking/patient/:patientId/current\n   */\n  async getCurrentByPatient(request, reply) {\n    try {\n      const { patientId } = request.params;\n      const patientIdNum = parseInt(patientId);\n\n      if (isNaN(patientIdNum)) {\n        reply.code(400);\n        return {\n          success: false,\n          error: { code: \"INVALID_PATIENT_ID\", message: \"Invalid patient ID\" },\n        };\n      }\n\n      const results = await db\n        .select()\n        .from(prognosis_tracking)\n        .where(\n          and(\n            eq(prognosis_tracking.patient_id, patientIdNum),\n            eq(prognosis_tracking.is_current, true),\n            isNull(prognosis_tracking.deleted_at)\n          )\n        )\n        .limit(1);\n\n      if (results.length === 0) {\n        reply.code(200);\n        return {\n          success: true,\n          data: null,\n          message: \"No current prognosis found for this patient\",\n        };\n      }\n\n      // Fetch clinical indicators for current prognosis\n      const indicators = await db\n        .select()\n        .from(prognosis_clinical_indicators)\n        .where(eq(prognosis_clinical_indicators.prognosis_tracking_id, results[0].id))\n        .orderBy(desc(prognosis_clinical_indicators.measurement_date));\n\n      reply.code(200);\n      return {\n        success: true,\n        data: {\n          ...results[0],\n          clinical_indicators: indicators,\n        },\n      };\n    } catch (error) {\n      logger.error(\"Error fetching current prognosis:\", error);\n      reply.code(500);\n      return {\n        success: false,\n        error: {\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Error fetching current prognosis\",\n        },\n      };\n    }\n  }\n\n  /**\n   * Get prognosis history for a patient\n   * GET /prognosis-tracking/patient/:patientId/history\n   */\n  async getHistoryByPatient(request, reply) {\n    try {\n      const { patientId } = request.params;\n      const { limit = 20, offset = 0 } = request.query;\n      const patientIdNum = parseInt(patientId);\n\n      if (isNaN(patientIdNum)) {\n        reply.code(400);\n        return {\n          success: false,\n          error: { code: \"INVALID_PATIENT_ID\", message: \"Invalid patient ID\" },\n        };\n      }\n\n      // Get all prognosis versions for patient\n      const versions = await db\n        .select()\n        .from(prognosis_tracking)\n        .where(\n          and(\n            eq(prognosis_tracking.patient_id, patientIdNum),\n            isNull(prognosis_tracking.deleted_at)\n          )\n        )\n        .orderBy(desc(prognosis_tracking.version))\n        .limit(parseInt(limit))\n        .offset(parseInt(offset));\n\n      // Get audit history\n      const auditHistory = await db\n        .select()\n        .from(prognosis_history)\n        .where(eq(prognosis_history.patient_id, patientIdNum))\n        .orderBy(desc(prognosis_history.change_date))\n        .limit(50);\n\n      reply.code(200);\n      return {\n        success: true,\n        data: {\n          versions,\n          audit_trail: auditHistory,\n        },\n      };\n    } catch (error) {\n      logger.error(\"Error fetching prognosis history:\", error);\n      reply.code(500);\n      return {\n        success: false,\n        error: {\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Error fetching prognosis history\",\n        },\n      };\n    }\n  }\n\n  /**\n   * Get a specific prognosis tracking record\n   * GET /prognosis-tracking/:id\n   */\n  async show(request, reply) {\n    try {\n      const { id } = request.params;\n      const recordId = parseInt(id);\n\n      if (isNaN(recordId)) {\n        reply.code(400);\n        return {\n          success: false,\n          error: { code: \"INVALID_ID\", message: \"Invalid prognosis tracking ID\" },\n        };\n      }\n\n      const results = await db\n        .select()\n        .from(prognosis_tracking)\n        .where(\n          and(\n            eq(prognosis_tracking.id, recordId),\n            isNull(prognosis_tracking.deleted_at)\n          )\n        )\n        .limit(1);\n\n      if (results.length === 0) {\n        reply.code(404);\n        return {\n          success: false,\n          error: { code: \"NOT_FOUND\", message: \"Prognosis tracking record not found\" },\n        };\n      }\n\n      // Fetch clinical indicators\n      const indicators = await db\n        .select()\n        .from(prognosis_clinical_indicators)\n        .where(eq(prognosis_clinical_indicators.prognosis_tracking_id, recordId))\n        .orderBy(desc(prognosis_clinical_indicators.measurement_date));\n\n      reply.code(200);\n      return {\n        success: true,\n        data: {\n          ...results[0],\n          clinical_indicators: indicators,\n        },\n      };\n    } catch (error) {\n      logger.error(\"Error fetching prognosis tracking record:\", error);\n      reply.code(500);\n      return {\n        success: false,\n        error: {\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Error fetching prognosis tracking record\",\n        },\n      };\n    }\n  }\n\n  /**\n   * Create a new prognosis tracking record\n   * POST /prognosis-tracking\n   */\n  async create(request, reply) {\n    try {\n      const userId = request.user?.id || null;\n      const {\n        patient_id,\n        disease_progression_status,\n        // Include other fields from schema\n        ...otherData\n      } = request.body;\n\n      // Validate required fields\n      if (!patient_id) {\n        reply.code(400);\n        return {\n          success: false,\n          error: { code: \"MISSING_PATIENT_ID\", message: \"Patient ID is required\" },\n        };\n      }\n\n      if (!disease_progression_status) {\n        reply.code(400);\n        return {\n          success: false,\n          error: {\n            code: \"MISSING_PROGRESSION_STATUS\",\n            message: \"Disease progression status is required\",\n          },\n        };\n      }\n\n      // Validate disease progression status\n      if (!Object.values(DISEASE_PROGRESSION_STATUS).includes(disease_progression_status)) {\n        reply.code(400);\n        return {\n          success: false,\n          error: {\n            code: \"INVALID_PROGRESSION_STATUS\",\n            message: `Invalid disease progression status. Valid values: ${Object.values(DISEASE_PROGRESSION_STATUS).join(\", \")}`,\n          },\n        };\n      }\n\n      const patientIdNum = parseInt(patient_id);\n\n      // Check if patient exists\n      const patientExists = await db\n        .select({ id: patients.id })\n        .from(patients)\n        .where(eq(patients.id, patientIdNum))\n        .limit(1);\n\n      if (patientExists.length === 0) {\n        reply.code(404);\n        return {\n          success: false,\n          error: { code: \"PATIENT_NOT_FOUND\", message: \"Patient not found\" },\n        };\n      }\n\n      // Mark any existing current prognosis as not current\n      const existingCurrent = await db\n        .select({ id: prognosis_tracking.id, version: prognosis_tracking.version })\n        .from(prognosis_tracking)\n        .where(\n          and(\n            eq(prognosis_tracking.patient_id, patientIdNum),\n            eq(prognosis_tracking.is_current, true),\n            isNull(prognosis_tracking.deleted_at)\n          )\n        )\n        .limit(1);\n\n      const now = new Date();\n      let previousVersionId = null;\n      let newVersion = 1;\n\n      if (existingCurrent.length > 0) {\n        previousVersionId = existingCurrent[0].id;\n        newVersion = existingCurrent[0].version + 1;\n\n        // Update existing to mark as not current\n        await db\n          .update(prognosis_tracking)\n          .set({\n            is_current: false,\n            superseded_at: now,\n            superseded_by_id: userId,\n            superseded_reason: otherData.superseded_reason || \"New prognosis created\",\n            updatedAt: now,\n          })\n          .where(eq(prognosis_tracking.id, existingCurrent[0].id));\n      }\n\n      // Create new prognosis tracking record\n      const newRecord = await db\n        .insert(prognosis_tracking)\n        .values({\n          patient_id: patientIdNum,\n          disease_progression_status,\n          version: newVersion,\n          is_current: true,\n          previous_version_id: previousVersionId,\n          prognosis_status: otherData.prognosis_status || \"ACTIVE\",\n          created_by_id: userId,\n          updated_by_id: userId,\n          createdAt: now,\n          updatedAt: now,\n          // Spread other valid fields\n          ...this._sanitizeInput(otherData),\n        })\n        .returning();\n\n      // Create history record\n      await db.insert(prognosis_history).values({\n        prognosis_tracking_id: newRecord[0].id,\n        patient_id: patientIdNum,\n        change_type: \"CREATE\",\n        change_date: now,\n        changed_by_id: userId,\n        snapshot: JSON.stringify(newRecord[0]),\n        ip_address: request.ip,\n        user_agent: request.headers[\"user-agent\"],\n        createdAt: now,\n      });\n\n      reply.code(201);\n      return {\n        success: true,\n        data: newRecord[0],\n        message: \"Prognosis tracking record created successfully\",\n      };\n    } catch (error) {\n      logger.error(\"Error creating prognosis tracking record:\", error);\n      reply.code(500);\n      return {\n        success: false,\n        error: {\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Error creating prognosis tracking record\",\n        },\n      };\n    }\n  }\n\n  /**\n   * Update a prognosis tracking record\n   * PUT /prognosis-tracking/:id\n   */\n  async update(request, reply) {\n    try {\n      const { id } = request.params;\n      const userId = request.user?.id || null;\n      const recordId = parseInt(id);\n\n      if (isNaN(recordId)) {\n        reply.code(400);\n        return {\n          success: false,\n          error: { code: \"INVALID_ID\", message: \"Invalid prognosis tracking ID\" },\n        };\n      }\n\n      // Check if record exists\n      const existing = await db\n        .select()\n        .from(prognosis_tracking)\n        .where(\n          and(\n            eq(prognosis_tracking.id, recordId),\n            isNull(prognosis_tracking.deleted_at)\n          )\n        )\n        .limit(1);\n\n      if (existing.length === 0) {\n        reply.code(404);\n        return {\n          success: false,\n          error: { code: \"NOT_FOUND\", message: \"Prognosis tracking record not found\" },\n        };\n      }\n\n      const updateData = request.body;\n      const now = new Date();\n\n      // Validate disease progression status if provided\n      if (\n        updateData.disease_progression_status &&\n        !Object.values(DISEASE_PROGRESSION_STATUS).includes(updateData.disease_progression_status)\n      ) {\n        reply.code(400);\n        return {\n          success: false,\n          error: {\n            code: \"INVALID_PROGRESSION_STATUS\",\n            message: `Invalid disease progression status. Valid values: ${Object.values(DISEASE_PROGRESSION_STATUS).join(\", \")}`,\n          },\n        };\n      }\n\n      // Track what changed\n      const changes = [];\n      const fieldsToTrack = [\n        \"disease_progression_status\",\n        \"prognosis_status\",\n        \"functional_status_score\",\n        \"is_imminently_dying\",\n        \"imminence_level\",\n      ];\n\n      for (const field of fieldsToTrack) {\n        if (updateData[field] !== undefined && updateData[field] !== existing[0][field]) {\n          changes.push({\n            field,\n            previous: existing[0][field],\n            new: updateData[field],\n          });\n        }\n      }\n\n      // Update the record\n      const updatedRecord = await db\n        .update(prognosis_tracking)\n        .set({\n          ...this._sanitizeInput(updateData),\n          updated_by_id: userId,\n          updatedAt: now,\n        })\n        .where(eq(prognosis_tracking.id, recordId))\n        .returning();\n\n      // Create history records for significant changes\n      for (const change of changes) {\n        await db.insert(prognosis_history).values({\n          prognosis_tracking_id: recordId,\n          patient_id: existing[0].patient_id,\n          change_type: change.field === \"prognosis_status\" ? \"STATUS_CHANGE\" : \"UPDATE\",\n          change_date: now,\n          changed_by_id: userId,\n          field_changed: change.field,\n          previous_value: String(change.previous),\n          new_value: String(change.new),\n          change_reason: updateData.change_reason,\n          snapshot: JSON.stringify(updatedRecord[0]),\n          ip_address: request.ip,\n          user_agent: request.headers[\"user-agent\"],\n          createdAt: now,\n        });\n      }\n\n      reply.code(200);\n      return {\n        success: true,\n        data: updatedRecord[0],\n        message: \"Prognosis tracking record updated successfully\",\n      };\n    } catch (error) {\n      logger.error(\"Error updating prognosis tracking record:\", error);\n      reply.code(500);\n      return {\n        success: false,\n        error: {\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Error updating prognosis tracking record\",\n        },\n      };\n    }\n  }\n\n  /**\n   * Soft delete a prognosis tracking record\n   * DELETE /prognosis-tracking/:id\n   */\n  async delete(request, reply) {\n    try {\n      const { id } = request.params;\n      const userId = request.user?.id || null;\n      const recordId = parseInt(id);\n\n      if (isNaN(recordId)) {\n        reply.code(400);\n        return {\n          success: false,\n          error: { code: \"INVALID_ID\", message: \"Invalid prognosis tracking ID\" },\n        };\n      }\n\n      const existing = await db\n        .select()\n        .from(prognosis_tracking)\n        .where(\n          and(\n            eq(prognosis_tracking.id, recordId),\n            isNull(prognosis_tracking.deleted_at)\n          )\n        )\n        .limit(1);\n\n      if (existing.length === 0) {\n        reply.code(404);\n        return {\n          success: false,\n          error: { code: \"NOT_FOUND\", message: \"Prognosis tracking record not found\" },\n        };\n      }\n\n      const now = new Date();\n\n      // Soft delete\n      await db\n        .update(prognosis_tracking)\n        .set({\n          deleted_at: now,\n          is_current: false,\n          prognosis_status: \"ARCHIVED\",\n          updated_by_id: userId,\n          updatedAt: now,\n        })\n        .where(eq(prognosis_tracking.id, recordId));\n\n      // Log deletion in history\n      await db.insert(prognosis_history).values({\n        prognosis_tracking_id: recordId,\n        patient_id: existing[0].patient_id,\n        change_type: \"ARCHIVE\",\n        change_date: now,\n        changed_by_id: userId,\n        change_reason: request.body?.reason || \"Record archived\",\n        ip_address: request.ip,\n        user_agent: request.headers[\"user-agent\"],\n        createdAt: now,\n      });\n\n      reply.code(200);\n      return {\n        success: true,\n        message: \"Prognosis tracking record archived successfully\",\n      };\n    } catch (error) {\n      logger.error(\"Error archiving prognosis tracking record:\", error);\n      reply.code(500);\n      return {\n        success: false,\n        error: {\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Error archiving prognosis tracking record\",\n        },\n      };\n    }\n  }\n\n  /**\n   * Add clinical indicator to a prognosis record\n   * POST /prognosis-tracking/:id/indicators\n   */\n  async addClinicalIndicator(request, reply) {\n    try {\n      const { id } = request.params;\n      const userId = request.user?.id || null;\n      const recordId = parseInt(id);\n\n      if (isNaN(recordId)) {\n        reply.code(400);\n        return {\n          success: false,\n          error: { code: \"INVALID_ID\", message: \"Invalid prognosis tracking ID\" },\n        };\n      }\n\n      // Verify prognosis exists\n      const existing = await db\n        .select({ id: prognosis_tracking.id, patient_id: prognosis_tracking.patient_id })\n        .from(prognosis_tracking)\n        .where(eq(prognosis_tracking.id, recordId))\n        .limit(1);\n\n      if (existing.length === 0) {\n        reply.code(404);\n        return {\n          success: false,\n          error: { code: \"NOT_FOUND\", message: \"Prognosis tracking record not found\" },\n        };\n      }\n\n      const {\n        indicator_type,\n        indicator_name,\n        measurement_date,\n        value_numeric,\n        value_text,\n        value_unit,\n        ...otherData\n      } = request.body;\n\n      // Validate required fields\n      if (!indicator_type || !indicator_name || !measurement_date) {\n        reply.code(400);\n        return {\n          success: false,\n          error: {\n            code: \"MISSING_REQUIRED_FIELDS\",\n            message: \"indicator_type, indicator_name, and measurement_date are required\",\n          },\n        };\n      }\n\n      // Validate indicator type\n      if (!Object.values(CLINICAL_INDICATOR_TYPES).includes(indicator_type)) {\n        reply.code(400);\n        return {\n          success: false,\n          error: {\n            code: \"INVALID_INDICATOR_TYPE\",\n            message: `Invalid indicator type. Valid values: ${Object.values(CLINICAL_INDICATOR_TYPES).join(\", \")}`,\n          },\n        };\n      }\n\n      const now = new Date();\n\n      // Get previous value for trend calculation\n      const previousIndicator = await db\n        .select()\n        .from(prognosis_clinical_indicators)\n        .where(\n          and(\n            eq(prognosis_clinical_indicators.patient_id, existing[0].patient_id),\n            eq(prognosis_clinical_indicators.indicator_type, indicator_type),\n            eq(prognosis_clinical_indicators.indicator_name, indicator_name)\n          )\n        )\n        .orderBy(desc(prognosis_clinical_indicators.measurement_date))\n        .limit(1);\n\n      let trendData = {};\n      if (previousIndicator.length > 0 && value_numeric !== undefined) {\n        const prevValue = parseFloat(previousIndicator[0].value_numeric);\n        const currValue = parseFloat(value_numeric);\n        const daysDiff = Math.floor(\n          (new Date(measurement_date) - new Date(previousIndicator[0].measurement_date)) /\n            (1000 * 60 * 60 * 24)\n        );\n\n        let trendDirection = \"STABLE\";\n        if (currValue > prevValue * 1.05) trendDirection = \"WORSENING\";\n        else if (currValue < prevValue * 0.95) trendDirection = \"IMPROVING\";\n\n        trendData = {\n          previous_value: prevValue,\n          change_percentage: ((currValue - prevValue) / prevValue) * 100,\n          days_since_previous: daysDiff,\n          trend_direction: trendDirection,\n        };\n      }\n\n      const newIndicator = await db\n        .insert(prognosis_clinical_indicators)\n        .values({\n          prognosis_tracking_id: recordId,\n          patient_id: existing[0].patient_id,\n          indicator_type,\n          indicator_name,\n          measurement_date: new Date(measurement_date),\n          value_numeric: value_numeric ? parseFloat(value_numeric) : null,\n          value_text,\n          value_unit,\n          recorded_by_id: userId,\n          createdAt: now,\n          updatedAt: now,\n          ...trendData,\n          ...otherData,\n        })\n        .returning();\n\n      reply.code(201);\n      return {\n        success: true,\n        data: newIndicator[0],\n        message: \"Clinical indicator added successfully\",\n      };\n    } catch (error) {\n      logger.error(\"Error adding clinical indicator:\", error);\n      reply.code(500);\n      return {\n        success: false,\n        error: {\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Error adding clinical indicator\",\n        },\n      };\n    }\n  }\n\n  /**\n   * Get clinical indicators for a prognosis record\n   * GET /prognosis-tracking/:id/indicators\n   */\n  async getClinicalIndicators(request, reply) {\n    try {\n      const { id } = request.params;\n      const { type, limit = 50, offset = 0 } = request.query;\n      const recordId = parseInt(id);\n\n      if (isNaN(recordId)) {\n        reply.code(400);\n        return {\n          success: false,\n          error: { code: \"INVALID_ID\", message: \"Invalid prognosis tracking ID\" },\n        };\n      }\n\n      let conditions = [eq(prognosis_clinical_indicators.prognosis_tracking_id, recordId)];\n\n      if (type) {\n        conditions.push(eq(prognosis_clinical_indicators.indicator_type, type));\n      }\n\n      const indicators = await db\n        .select()\n        .from(prognosis_clinical_indicators)\n        .where(and(...conditions))\n        .orderBy(desc(prognosis_clinical_indicators.measurement_date))\n        .limit(parseInt(limit))\n        .offset(parseInt(offset));\n\n      reply.code(200);\n      return {\n        success: true,\n        data: indicators,\n      };\n    } catch (error) {\n      logger.error(\"Error fetching clinical indicators:\", error);\n      reply.code(500);\n      return {\n        success: false,\n        error: {\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Error fetching clinical indicators\",\n        },\n      };\n    }\n  }\n\n  /**\n   * Record outcome for a prognosis\n   * POST /prognosis-tracking/:id/outcomes\n   */\n  async recordOutcome(request, reply) {\n    try {\n      const { id } = request.params;\n      const userId = request.user?.id || null;\n      const recordId = parseInt(id);\n\n      if (isNaN(recordId)) {\n        reply.code(400);\n        return {\n          success: false,\n          error: { code: \"INVALID_ID\", message: \"Invalid prognosis tracking ID\" },\n        };\n      }\n\n      // Verify prognosis exists\n      const existing = await db\n        .select()\n        .from(prognosis_tracking)\n        .where(eq(prognosis_tracking.id, recordId))\n        .limit(1);\n\n      if (existing.length === 0) {\n        reply.code(404);\n        return {\n          success: false,\n          error: { code: \"NOT_FOUND\", message: \"Prognosis tracking record not found\" },\n        };\n      }\n\n      const {\n        outcome_type,\n        outcome_date,\n        outcome_location,\n        actual_los_days,\n        ...otherData\n      } = request.body;\n\n      // Validate required fields\n      if (!outcome_type) {\n        reply.code(400);\n        return {\n          success: false,\n          error: { code: \"MISSING_OUTCOME_TYPE\", message: \"Outcome type is required\" },\n        };\n      }\n\n      const now = new Date();\n      const prognosisData = existing[0];\n\n      // Calculate accuracy metrics\n      let losVariance = null;\n      let losAccuracy = null;\n      if (actual_los_days && prognosisData.expected_length_of_stay_days) {\n        losVariance = actual_los_days - prognosisData.expected_length_of_stay_days;\n        if (Math.abs(losVariance) <= 7) {\n          losAccuracy = \"ACCURATE\";\n        } else if (losVariance > 0) {\n          losAccuracy = \"UNDERESTIMATED\";\n        } else {\n          losAccuracy = \"OVERESTIMATED\";\n        }\n      }\n\n      const newOutcome = await db\n        .insert(prognosis_outcomes)\n        .values({\n          prognosis_tracking_id: recordId,\n          patient_id: prognosisData.patient_id,\n          outcome_type,\n          outcome_date: outcome_date ? new Date(outcome_date) : null,\n          outcome_location,\n          prognosis_date: prognosisData.createdAt,\n          predicted_los_days: prognosisData.expected_length_of_stay_days,\n          actual_los_days: actual_los_days ? parseInt(actual_los_days) : null,\n          los_variance_days: losVariance,\n          los_accuracy_category: losAccuracy,\n          predicted_imminence_level: prognosisData.imminence_level,\n          analyzed_by_id: userId,\n          analysis_date: now,\n          createdAt: now,\n          updatedAt: now,\n          ...otherData,\n        })\n        .returning();\n\n      // Update prognosis status\n      await db\n        .update(prognosis_tracking)\n        .set({\n          prognosis_status: \"FINALIZED\",\n          is_current: false,\n          updatedAt: now,\n          updated_by_id: userId,\n        })\n        .where(eq(prognosis_tracking.id, recordId));\n\n      reply.code(201);\n      return {\n        success: true,\n        data: newOutcome[0],\n        message: \"Outcome recorded successfully\",\n      };\n    } catch (error) {\n      logger.error(\"Error recording outcome:\", error);\n      reply.code(500);\n      return {\n        success: false,\n        error: {\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Error recording outcome\",\n        },\n      };\n    }\n  }\n\n  /**\n   * Get prognosis trends for a patient\n   * GET /prognosis-tracking/patient/:patientId/trends\n   */\n  async getPatientTrends(request, reply) {\n    try {\n      const { patientId } = request.params;\n      const { indicator_type, days = 30 } = request.query;\n      const patientIdNum = parseInt(patientId);\n\n      if (isNaN(patientIdNum)) {\n        reply.code(400);\n        return {\n          success: false,\n          error: { code: \"INVALID_PATIENT_ID\", message: \"Invalid patient ID\" },\n        };\n      }\n\n      const startDate = new Date();\n      startDate.setDate(startDate.getDate() - parseInt(days));\n\n      let conditions = [\n        eq(prognosis_clinical_indicators.patient_id, patientIdNum),\n        sql`${prognosis_clinical_indicators.measurement_date} >= ${startDate}`,\n      ];\n\n      if (indicator_type) {\n        conditions.push(eq(prognosis_clinical_indicators.indicator_type, indicator_type));\n      }\n\n      const indicators = await db\n        .select()\n        .from(prognosis_clinical_indicators)\n        .where(and(...conditions))\n        .orderBy(prognosis_clinical_indicators.measurement_date);\n\n      // Group by indicator type and name for trend analysis\n      const trends = {};\n      for (const indicator of indicators) {\n        const key = `${indicator.indicator_type}_${indicator.indicator_name}`;\n        if (!trends[key]) {\n          trends[key] = {\n            type: indicator.indicator_type,\n            name: indicator.indicator_name,\n            unit: indicator.value_unit,\n            data: [],\n          };\n        }\n        trends[key].data.push({\n          date: indicator.measurement_date,\n          value: indicator.value_numeric || indicator.value_text,\n          is_abnormal: indicator.is_abnormal,\n          is_critical: indicator.is_critical,\n        });\n      }\n\n      reply.code(200);\n      return {\n        success: true,\n        data: {\n          patient_id: patientIdNum,\n          period_days: parseInt(days),\n          trends: Object.values(trends),\n        },\n      };\n    } catch (error) {\n      logger.error(\"Error fetching patient trends:\", error);\n      reply.code(500);\n      return {\n        success: false,\n        error: {\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Error fetching patient trends\",\n        },\n      };\n    }\n  }\n\n  /**\n   * Get enum values for dropdowns\n   * GET /prognosis-tracking/enums\n   */\n  async getEnums(request, reply) {\n    return {\n      success: true,\n      data: {\n        disease_progression_status: DISEASE_PROGRESSION_STATUS,\n        prognosis_status: PROGNOSIS_STATUS,\n        confidence_levels: CONFIDENCE_LEVELS,\n        imminence_levels: IMMINENCE_LEVELS,\n        functional_status_scales: FUNCTIONAL_STATUS_SCALES,\n        clinical_indicator_types: CLINICAL_INDICATOR_TYPES,\n      },\n    };\n  }\n\n  /**\n   * Sanitize input to only allow valid schema fields\n   * @private\n   */\n  _sanitizeInput(data) {\n    // List of allowed fields that can be set\n    const allowedFields = [\n      'prognosis_status',\n      'admission_date',\n      'expected_discharge_date',\n      'expected_length_of_stay_days',\n      'length_of_stay_range_min_days',\n      'length_of_stay_range_max_days',\n      'length_of_stay_confidence_level',\n      'length_of_stay_notes',\n      'prognosis_months',\n      'prognosis_less_than_6_months',\n      'terminal_diagnosis_confirmed',\n      'terminal_diagnosis_date',\n      'disease_progression_trend',\n      'progression_rate',\n      'progression_since_last_assessment',\n      'disease_progression_notes',\n      'vital_signs_trend',\n      'vital_signs_summary',\n      'vital_signs_last_assessment_date',\n      'lab_values_summary',\n      'lab_values_trend',\n      'lab_values_last_date',\n      'functional_status_score',\n      'functional_status_scale',\n      'functional_status_trend',\n      'previous_functional_score',\n      'functional_status_date',\n      'functional_status_notes',\n      'pps_ambulation',\n      'pps_activity_evidence_of_disease',\n      'pps_self_care',\n      'pps_intake',\n      'pps_conscious_level',\n      'primary_diagnosis_icd10',\n      'primary_diagnosis_description',\n      'secondary_diagnoses',\n      'comorbidities',\n      'diagnosis_related_prognosis_factors',\n      'symptom_burden_score',\n      'symptom_burden_level',\n      'primary_symptoms',\n      'symptom_management_effectiveness',\n      'is_imminently_dying',\n      'imminence_level',\n      'imminence_indicators',\n      'imminence_assessment_date',\n      'days_to_death_estimate',\n      'hours_to_death_estimate',\n      'patient_awareness_of_prognosis',\n      'family_awareness_of_prognosis',\n      'prognosis_discussion_date',\n      'prognosis_discussed_with',\n      'goals_of_care_aligned',\n      'goals_of_care_notes',\n      'overall_confidence_level',\n      'confidence_percentage',\n      'uncertainty_factors',\n      'prediction_model_used',\n      'surprise_question_response',\n      'complications',\n      'unexpected_events',\n      'prognosis_modifying_factors',\n      'last_review_date',\n      'next_review_date',\n      'review_frequency_days',\n      'review_notes',\n      'requires_idg_review',\n      'idg_review_date',\n      'idg_review_outcome',\n      'clinical_summary',\n      'prognosis_rationale',\n      'treatment_response',\n      'additional_notes',\n      'signature',\n      'signed_at',\n      'signed_by_id',\n      'cosignature',\n      'cosigned_at',\n      'cosigned_by_id',\n      'requires_physician_signature',\n      'physician_signature_date',\n    ];\n\n    const sanitized = {};\n    for (const field of allowedFields) {\n      if (data[field] !== undefined) {\n        sanitized[field] = data[field];\n      }\n    }\n    return sanitized;\n  }\n}\n\nexport default new PrognosisTrackingController();\n"
}

You've hit your limit Â· resets 4pm (America/Los_Angeles)