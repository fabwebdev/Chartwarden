{
  "id": "vital-signs-controller",
  "category": "API",
  "title": "Vital Signs CRUD Controller",
  "description": "Vital Signs Management API - Backend Controller Implementation\n\nBuild a HIPAA-compliant RESTful API controller for managing patient vital signs with complete CRUD operations, clinical validation, role-based access control, and comprehensive audit logging.\n\nAPI Endpoints:\n\n1. Create Vital Signs Record\n   - POST /api/patients/{patientId}/vital-signs\n   - Accept: temperature, blood pressure (systolic/diastolic), heart rate, respiratory rate, oxygen saturation, optional notes\n   - Validate patient exists and user has write permissions\n   - Return 201 Created with full record including generated ID, timestamps, and recorded-by user\n   - Support both imperial (°F, mmHg) and metric (°C) units with automatic conversion and storage normalization\n\n2. List Patient Vital Signs\n   - GET /api/patients/{patientId}/vital-signs\n   - Query params: dateFrom, dateTo, limit (default 50, max 200), offset, sortBy, sortOrder (asc/desc)\n   - Return paginated results with metadata (totalCount, currentPage, totalPages, hasNext, hasPrevious)\n   - Filter out soft-deleted records by default; include deletedAt param to show deleted records (admin only)\n   - Apply clinical flags to abnormal values in response\n\n3. Get Single Vital Signs Record\n   - GET /api/vital-signs/{recordId}\n   - Return complete record with full audit trail (created, modified, deleted events)\n   - Include user information for who recorded, modified, or deleted\n   - Return 404 if record doesn't exist or user lacks permission\n\n4. Full Record Update\n   - PUT /api/vital-signs/{recordId}\n   - Require all vital sign fields (replaces entire record)\n   - Implement optimistic locking using version field or lastModifiedAt timestamp\n   - Update lastModifiedAt and lastModifiedBy fields\n   - Create audit log entry with previous values\n   - Return 409 Conflict if version mismatch detected\n\n5. Partial Record Update\n   - PATCH /api/vital-signs/{recordId}\n   - Accept subset of fields to update\n   - Preserve unmodified fields\n   - Same versioning and audit requirements as PUT\n   - Validate that at least one field is being updated\n\n6. Soft Delete Record\n   - DELETE /api/vital-signs/{recordId}\n   - Set deletedAt timestamp and deletedBy user ID\n   - Do not physically remove record from database\n   - Create audit log entry\n   - Return 204 No Content on success\n   - Prevent double-deletion (return 410 Gone if already deleted)\n\nClinical Validation Rules:\n\nTemperature:\n- Valid range: 95-106°F (35-41.1°C)\n- Critical alert: <96.8°F or >100.4°F (36°C or >38°C)\n- Reject values outside valid range\n\nBlood Pressure:\n- Systolic: 70-200 mmHg (warn if <90 or >140)\n- Diastolic: 40-130 mmHg (warn if <60 or >90)\n- Validate systolic > diastolic\n- Reject if outside valid ranges\n\nHeart Rate:\n- Valid range: 40-200 bpm\n- Normal resting: 60-100 bpm (flag outside this range)\n\nRespiratory Rate:\n- Valid range: 8-40 breaths/min\n- Normal range: 12-20 breaths/min (flag outside)\n\nOxygen Saturation:\n- Valid range: 70-100%\n- Critical threshold: <95% (flag for immediate attention)\n- Warn if <90% (hypoxemia)\n\nCross-field validation:\n- Recorded timestamp must not be in future\n- If patient birthdate available, reject timestamps before birth\n- Detect potential duplicates (same patient, measurements within 2 minutes)\n\nData Model Schema:\n\n```\nVitalSignsRecord:\n  - id (UUID, primary key)\n  - patientId (UUID, foreign key, indexed)\n  - recordedAt (timestamp with timezone, indexed)\n  - temperature (decimal, nullable)\n  - temperatureUnit (enum: F, C)\n  - systolicBP (integer, nullable)\n  - diastolicBP (integer, nullable)\n  - heartRate (integer, nullable)\n  - respiratoryRate (integer, nullable)\n  - oxygenSaturation (decimal, nullable)\n  - notes (text, nullable, max 1000 chars)\n  - createdAt (timestamp with timezone)\n  - createdBy (UUID, foreign key to users)\n  - lastModifiedAt (timestamp with timezone)\n  - lastModifiedBy (UUID, foreign key to users, nullable)\n  - deletedAt (timestamp with timezone, nullable)\n  - deletedBy (UUID, foreign key to users, nullable)\n  - version (integer, for optimistic locking)\n\nAuditLog:\n  - id (UUID, primary key)\n  - recordId (UUID, foreign key)\n  - action (enum: CREATE, UPDATE, DELETE)\n  - userId (UUID)\n  - timestamp (timestamp with timezone)\n  - ipAddress (string)\n  - sessionId (string)\n  - previousValues (JSON, for updates)\n  - newValues (JSON, for updates/creates)\n```\n\nAuthorization & Security:\n\nRole-based permissions:\n- Nurse: Create, read vital signs for assigned patients\n- Doctor: Create, read, update vital signs for assigned patients\n- Admin: Full CRUD access, can view deleted records and audit logs\n\nPer-request checks:\n1. Verify valid JWT or session token (401 if missing/invalid)\n2. Extract user ID and roles from token\n3. Validate user has permission for requested action (403 if denied)\n4. For patient-specific endpoints, verify user-patient relationship in assignments table\n5. For updates/deletes, verify record exists and is accessible (404 if not)\n\nSecurity measures:\n- Use parameterized queries/ORM to prevent SQL injection\n- Sanitize all text inputs (especially notes field)\n- Implement rate limiting: 100 requests/minute per user, 10 creates/minute per patient\n- Log all failed authorization attempts\n- Encrypt PHI at rest and in transit\n- Set security headers (HSTS, CSP, X-Content-Type-Options)\n\nError Response Structure:\n\n```json\n{\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"One or more fields contain invalid values\",\n    \"timestamp\": \"2025-01-15T10:30:00Z\",\n    \"path\": \"/api/vital-signs/123\",\n    \"fields\": [\n      {\n        \"field\": \"heartRate\",\n        \"message\": \"Heart rate must be between 40 and 200 bpm\",\n        \"rejectedValue\": 250\n      }\n    ]\n  }\n}\n```\n\nHTTP Status Codes:\n- 200 OK - Successful GET, PUT, PATCH\n- 201 Created - Successful POST\n- 204 No Content - Successful DELETE\n- 400 Bad Request - Malformed request syntax, invalid JSON\n- 401 Unauthorized - Missing or invalid authentication token\n- 403 Forbidden - Valid auth but insufficient permissions\n- 404 Not Found - Patient or record doesn't exist\n- 409 Conflict - Optimistic locking version mismatch\n- 410 Gone - Attempting to modify deleted record\n- 422 Unprocessable Entity - Valid syntax but failed validation rules\n- 429 Too Many Requests - Rate limit exceeded\n- 500 Internal Server Error - Database failures, unexpected exceptions\n- 503 Service Unavailable - Database connection issues\n\nConcurrency Handling:\n\nOptimistic locking implementation:\n1. Include version field in all responses\n2. Require version in PUT/PATCH/DELETE requests\n3. In transaction, SELECT record and check version matches\n4. If mismatch, return 409 with current version\n5. If match, increment version and proceed with update\n6. Commit transaction\n\nRace condition scenarios:\n- Simultaneous creates for same patient/timestamp - allow if >2 minutes apart, otherwise return 409 with duplicate warning\n- Simultaneous updates to same record - version check prevents, first commit wins\n- Update during delete - version check prevents\n- Read during update - use database isolation level READ_COMMITTED\n\nTesting Requirements:\n\nUnit Tests (mock database/dependencies):\n- CRUD operation success paths\n- All validation rules with boundary values (e.g., temp exactly 95°F, 106°F)\n- Authorization checks for each role and permission combination\n- Error handling for each status code scenario\n- Unit conversion accuracy (°F to °C and vice versa)\n- Optimistic locking version conflicts\n- Audit log entry creation\n\nIntegration Tests (actual database):\n- End-to-end API request/response flows\n- Database transaction rollback on errors\n- Pagination with various limit/offset combinations\n- Date range filtering accuracy\n- Soft delete and retrieval of non-deleted records\n- Concurrent update scenarios with multiple threads\n\nTest Data Fixtures:\n- 3 test patients with different access levels\n- 3 test users (nurse, doctor, admin) with appropriate roles\n- 20+ vital signs records with varied measurements\n- Include edge cases: minimum values, maximum values, critical values\n- Records in different states (active, deleted, recently modified)\n\nCoverage Goals:\n- Minimum 80% line coverage\n- 100% coverage of validation logic\n- 100% coverage of authorization checks\n- All error paths tested\n\nDocumentation Deliverables:\n\n1. OpenAPI 3.0 Specification\n   - Complete endpoint definitions with request/response schemas\n   - Authentication scheme (Bearer token)\n   - Example requests with curl commands\n   - Example responses for success and error cases\n   - Enum definitions for units, roles, error codes\n\n2. API Usage Guide\n   - Authentication flow\n   - Common workflows (record vitals, retrieve history, update reading)\n   - Pagination best practices\n   - Handling validation errors\n   - Rate limiting guidance\n\n3. Error Reference\n   - Complete list of error codes\n   - Cause and resolution for each error\n   - Example error responses\n\n4. Developer Setup\n   - Database schema migration scripts\n   - Seed data for testing\n   - Environment variable configuration\n   - Required dependencies\n\nPerformance Requirements:\n\nDatabase Optimization:\n- Composite index on (patientId, recordedAt DESC) for filtered queries\n- Index on deletedAt for filtering soft-deleted records\n- Connection pool with min 10, max 50 connections\n- Query timeout of 5 seconds\n- Use EXPLAIN to verify query plans use indexes\n\nResponse Time Targets:\n- Single record GET: <100ms at p95\n- List endpoint: <300ms at p95 for 50 records\n- Create operation: <200ms at p95\n- Update operation: <250ms at p95\n\nCaching Strategy:\n- Cache patient authorization lookups for 5 minutes\n- Consider read-through cache for frequently accessed vital signs (recent 24 hours)\n- Invalidate cache on updates/deletes\n- Use Redis or similar for distributed caching\n\nPagination Limits:\n- Default page size: 50 records\n- Maximum page size: 200 records\n- Return 400 if requested limit exceeds maximum\n\nCompliance Considerations:\n\nHIPAA Requirements:\n- Encrypt all PHI fields at rest using AES-256\n- Use TLS 1.2+ for data in transit\n- Maintain audit logs for minimum 6 years\n- Implement automatic session timeout after 15 minutes inactivity\n- Ensure audit logs cannot be modified (append-only table with no UPDATE/DELETE permissions)\n\nFHIR Alignment:\n- Consider mapping to FHIR Observation resource structure\n- Use LOINC codes for vital sign types if interoperability needed\n- Support standard units (UCUM codes)\n\nData Retention:\n- Retain vital signs indefinitely (medical record requirement)\n- Retain audit logs for 6 years minimum\n- Implement archival strategy for records >7 years old\n\nEdge Cases to Handle:\n\n1. Missing optional measurements - Allow partial vital signs, validate at least one measurement present\n2. Rapid successive readings - Allow but flag duplicates within 2-minute window\n3. Patient deleted while vitals exist - Soft delete should cascade or prevent patient deletion\n4. Timezone issues - Store all timestamps in UTC, accept ISO 8601 format with timezone\n5. Extremely old records - Validate recordedAt is after patient birthdate if available\n6. Update to deleted record - Return 410 Gone with message\n7. Bulk operations - Implement batch create endpoint if needed (POST /api/patients/{patientId}/vital-signs/batch)\n8. Very large date ranges - Enforce maximum range of 1 year per query\n9. Invalid patient-user assignments - Cache and refresh assignment lookups\n10. Measurement unit mismatches - Always store in standardized units (°F, mmHg internally), convert on input/output as needed\n\nImplementation Phases:\n\nPhase 1 - Core CRUD (Week 1):\n- Database schema and migrations\n- POST and GET endpoints with basic validation\n- Authentication integration\n- Unit tests for core functionality\n\nPhase 2 - Advanced Features (Week 2):\n- PUT, PATCH, DELETE endpoints\n- Optimistic locking\n- Comprehensive validation with clinical ranges\n- Pagination and filtering\n- Integration tests\n\nPhase 3 - Security & Audit (Week 3):\n- Role-based authorization\n- Audit logging\n- Rate limiting\n- Security hardening\n- Performance optimization\n\nPhase 4 - Documentation & Polish (Week 4):\n- OpenAPI specification\n- API documentation\n- Error handling refinement\n- Performance testing and tuning\n- Code coverage review\n\nSuccess Criteria:\n- All endpoints functional and tested\n- 80%+ code coverage achieved\n- API documentation complete\n- Security review passed\n- Performance targets met\n- HIPAA compliance verified\n- Successfully handles 100 concurrent users\n- Zero SQL injection vulnerabilities\n- All edge cases handled gracefully",
  "status": "completed",
  "priority": 1,
  "complexity": "moderate",
  "dependencies": [
    "vital-signs-schema",
    "casl-authorization"
  ],
  "createdAt": "2025-12-31T05:55:26.241Z",
  "updatedAt": "2026-01-01T06:51:15.369Z",
  "skipTests": false,
  "model": "opus",
  "thinkingLevel": "none",
  "imagePaths": [],
  "textFilePaths": [],
  "branchName": "main",
  "planningMode": "skip",
  "requirePlanApproval": false,
  "startedAt": "2026-01-01T06:29:22.778Z"
}