
ðŸ”§ Tool: TodoWrite
Input: {
  "todos": [
    {
      "content": "Explore existing codebase structure and patterns",
      "status": "in_progress",
      "activeForm": "Exploring existing codebase structure and patterns"
    },
    {
      "content": "Design QAPI database schema",
      "status": "pending",
      "activeForm": "Designing QAPI database schema"
    },
    {
      "content": "Implement schema files",
      "status": "pending",
      "activeForm": "Implementing schema files"
    },
    {
      "content": "Create controllers for QAPI endpoints",
      "status": "pending",
      "activeForm": "Creating controllers for QAPI endpoints"
    },
    {
      "content": "Create routes for QAPI endpoints",
      "status": "pending",
      "activeForm": "Creating routes for QAPI endpoints"
    },
    {
      "content": "Create migration file",
      "status": "pending",
      "activeForm": "Creating migration file"
    },
    {
      "content": "Verify implementation with Playwright",
      "status": "pending",
      "activeForm": "Verifying implementation with Playwright"
    }
  ]
}

ðŸ”§ Tool: Task
Input: {
  "description": "Explore QAPI codebase patterns",
  "prompt": "Explore the codebase to understand:\n1. The existing database schema patterns in services/api/src/db/schemas/\n2. The controller patterns in services/api/src/controllers/\n3. The route patterns in services/api/src/routes/\n4. The migration file patterns in services/api/database/migrations/drizzle/\n5. Any existing QAPI-related files\n\nProvide a summary of the patterns used including:\n- How schemas are defined (Drizzle ORM syntax)\n- Standard fields used (id, timestamps, audit fields)\n- How relationships are defined\n- Controller structure\n- Route structure\n- Migration file naming convention",
  "subagent_type": "Explore"
}

ðŸ”§ Tool: Glob
Input: {
  "pattern": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/*.js"
}

ðŸ”§ Tool: Glob
Input: {
  "pattern": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/controllers/*.js"
}

ðŸ”§ Tool: Glob
Input: {
  "pattern": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/routes/*.js"
}

ðŸ”§ Tool: Glob
Input: {
  "pattern": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/database/migrations/drizzle/*.sql"
}

ðŸ”§ Tool: Grep
Input: {
  "pattern": "qapi|QAPI",
  "path": "/Users/fabrice/Sites/chartwarden/Chartwarden",
  "output_mode": "files_with_matches"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/patient.schema.js"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/qapi.schema.js"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/benefitPeriod.schema.js"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/auditLog.schema.js"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/controllers/QAPI.controller.js"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/routes/qapi.routes.js"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/controllers/Patient.controller.js",
  "limit": 100
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/database/migrations/drizzle/0042_admin_settings.sql"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "ls -la /Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/index.js",
  "description": "Check schema index file location"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/index.js",
  "limit": 80
}

ðŸ”§ Tool: Grep
Input: {
  "pattern": "register.*routes|qapiRoutes|api\\.routes",
  "path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/server.js",
  "output_mode": "content",
  "head_limit": 50
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/controllers/benefitPeriod.controller.js",
  "limit": 150
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/controllers/Billing.controller.js",
  "limit": 150
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/routes/api.routes.js",
  "limit": 100
}

Now I have a comprehensive understanding of the codebase patterns. Let me also check the existing QAPI schema to understand what's already implemented.

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/qapi.schema.js"
}

The QAPI schema already exists with basic tables. I need to extend it with more comprehensive quality assurance and performance tracking as specified in the feature requirements. Let me update the todo list and review what additional tables are needed based on the requirements.

ðŸ”§ Tool: TodoWrite
Input: {
  "todos": [
    {
      "content": "Explore existing codebase structure and patterns",
      "status": "completed",
      "activeForm": "Exploring existing codebase structure and patterns"
    },
    {
      "content": "Design additional QAPI schema tables for comprehensive metrics tracking",
      "status": "in_progress",
      "activeForm": "Designing additional QAPI schema tables for comprehensive metrics tracking"
    },
    {
      "content": "Implement enhanced schema with metrics, thresholds, alerts, and initiative tracking",
      "status": "pending",
      "activeForm": "Implementing enhanced schema with metrics, thresholds, alerts, and initiative tracking"
    },
    {
      "content": "Create/update controllers for QAPI endpoints",
      "status": "pending",
      "activeForm": "Creating/updating controllers for QAPI endpoints"
    },
    {
      "content": "Create/update routes for QAPI endpoints",
      "status": "pending",
      "activeForm": "Creating/updating routes for QAPI endpoints"
    },
    {
      "content": "Create migration file",
      "status": "pending",
      "activeForm": "Creating migration file"
    },
    {
      "content": "Register new routes in api.routes.js",
      "status": "pending",
      "activeForm": "Registering new routes in api.routes.js"
    },
    {
      "content": "Verify implementation with Playwright",
      "status": "pending",
      "activeForm": "Verifying implementation with Playwright"
    }
  ]
}

Based on the feature requirements and the existing QAPI schema, I need to add the following additional tables:

1. **qapi_metric_definitions** - Flexible metric type definitions with extensible schema
2. **qapi_metric_values** - Time-series metric values with context
3. **qapi_metric_thresholds** - Threshold definitions for alerting and SLA tracking  
4. **qapi_improvement_initiatives** - Enhanced initiative tracking with lifecycle management
5. **qapi_initiative_metrics** - Many-to-many relationship between metrics and initiatives
6. **qapi_metric_snapshots** - Before/after metric snapshots for initiative impact analysis
7. **qapi_initiative_dependencies** - Initiative dependencies tracking
8. **qapi_product_areas** - Product area/component hierarchy
9. **qapi_tags** - Tags for flexible categorization
10. **qapi_entity_tags** - Many-to-many relationship for tagging entities
11. **qapi_metric_aggregations** - Materialized summary data for dashboard performance
12. **qapi_webhooks** - Webhook configurations for threshold breach notifications
13. **qapi_webhook_events** - Webhook event log
14. **qapi_audit_log** - Comprehensive audit trail for all changes

Let me implement the enhanced schema.

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/index.js"
}

Now let me check the existing QAPI controller and routes to understand what's already implemented.

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/controllers/QAPI.controller.js"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/routes/qapi.routes.js"
}

Now I have a complete picture. The existing QAPI module has basic functionality. Based on the feature requirements, I need to extend it with comprehensive metric definitions, thresholds, initiative tracking with dependencies, and more. Let me update the todo list and start implementing.

ðŸ”§ Tool: TodoWrite
Input: {
  "todos": [
    {
      "content": "Explore existing codebase structure and patterns",
      "status": "completed",
      "activeForm": "Exploring existing codebase structure and patterns"
    },
    {
      "content": "Design additional QAPI schema tables for comprehensive metrics tracking",
      "status": "completed",
      "activeForm": "Designing additional QAPI schema tables for comprehensive metrics tracking"
    },
    {
      "content": "Implement enhanced schema with metrics, thresholds, alerts, and initiative tracking",
      "status": "in_progress",
      "activeForm": "Implementing enhanced schema with metrics, thresholds, alerts, and initiative tracking"
    },
    {
      "content": "Create/update controllers for QAPI endpoints",
      "status": "pending",
      "activeForm": "Creating/updating controllers for QAPI endpoints"
    },
    {
      "content": "Create/update routes for QAPI endpoints",
      "status": "pending",
      "activeForm": "Creating/updating routes for QAPI endpoints"
    },
    {
      "content": "Create migration file",
      "status": "pending",
      "activeForm": "Creating migration file"
    },
    {
      "content": "Register new routes in api.routes.js",
      "status": "pending",
      "activeForm": "Registering new routes in api.routes.js"
    },
    {
      "content": "Verify implementation with Playwright",
      "status": "pending",
      "activeForm": "Verifying implementation with Playwright"
    }
  ]
}

Now I'll create the comprehensive QAPI schema extension. I'll add it as a new file to keep it organized.

ðŸ”§ Tool: Write
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/qapiMetrics.schema.js",
  "content": "import { pgTable, bigint, varchar, text, timestamp, boolean, jsonb, integer, date, decimal, index, uniqueIndex } from 'drizzle-orm/pg-core';\nimport { users } from './user.schema.js';\n\n/**\n * QAPI Metrics and Performance Tracking Schema\n *\n * Purpose: Comprehensive quality assurance metrics, threshold alerts,\n * improvement initiatives, and performance tracking for hospice care\n *\n * Compliance: CMS Conditions of Participation (CoPs), HIPAA, 21 CFR Part 11\n *\n * Tables:\n * - qapi_metric_definitions: Flexible metric type definitions with extensible schema\n * - qapi_metric_values: Time-series metric values with context\n * - qapi_metric_thresholds: Threshold definitions for alerting and SLA tracking\n * - qapi_improvement_initiatives: Enhanced initiative tracking with lifecycle management\n * - qapi_initiative_metrics: Many-to-many relationship between metrics and initiatives\n * - qapi_metric_snapshots: Before/after metric snapshots for initiative impact analysis\n * - qapi_initiative_dependencies: Initiative dependencies tracking\n * - qapi_product_areas: Product area/component hierarchy for filtering and grouping\n * - qapi_tags: Tags for flexible cross-cutting categorization\n * - qapi_entity_tags: Many-to-many relationship for tagging entities\n * - qapi_metric_aggregations: Materialized summary data for dashboard performance\n * - qapi_webhooks: Webhook configurations for threshold breach notifications\n * - qapi_webhook_events: Webhook event log\n * - qapi_change_log: Comprehensive audit trail for all QAPI changes\n */\n\n/**\n * Product Areas Table\n * Hierarchical product area/component structure for filtering and grouping\n */\nexport const qapi_product_areas = pgTable('qapi_product_areas', {\n  id: bigint('id', { mode: 'number' }).primaryKey().generatedByDefaultAsIdentity(),\n\n  // Identification\n  name: varchar('name', { length: 255 }).notNull(),\n  code: varchar('code', { length: 50 }).notNull(),\n  description: text('description'),\n\n  // Hierarchy\n  parent_id: bigint('parent_id', { mode: 'number' }),\n  level: integer('level').default(0).notNull(), // 0 = root, 1 = child, etc.\n  path: text('path'), // Materialized path for efficient tree queries (e.g., \"/1/5/12\")\n\n  // Ownership\n  department: varchar('department', { length: 255 }),\n  team: varchar('team', { length: 255 }),\n  owner_id: text('owner_id').references(() => users.id),\n\n  // Status\n  is_active: boolean('is_active').default(true).notNull(),\n\n  // Metadata\n  metadata: jsonb('metadata'),\n\n  // Audit fields\n  created_by_id: text('created_by_id').references(() => users.id),\n  updated_by_id: text('updated_by_id').references(() => users.id),\n  deleted_at: timestamp('deleted_at'),\n  deleted_by_id: text('deleted_by_id').references(() => users.id),\n  version: integer('version').default(1).notNull(),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull()\n}, (table) => ({\n  codeIdx: uniqueIndex('idx_qapi_product_areas_code').on(table.code),\n  parentIdx: index('idx_qapi_product_areas_parent').on(table.parent_id),\n  activeIdx: index('idx_qapi_product_areas_active').on(table.is_active)\n}));\n\n/**\n * Tags Table\n * Flexible categorization tags for cross-cutting concerns\n */\nexport const qapi_tags = pgTable('qapi_tags', {\n  id: bigint('id', { mode: 'number' }).primaryKey().generatedByDefaultAsIdentity(),\n\n  // Tag details\n  name: varchar('name', { length: 100 }).notNull(),\n  slug: varchar('slug', { length: 100 }).notNull(),\n  description: text('description'),\n  color: varchar('color', { length: 7 }), // Hex color code\n\n  // Categorization\n  category: varchar('category', { length: 100 }), // QUALITY, SAFETY, COMPLIANCE, OPERATIONAL, etc.\n\n  // Status\n  is_active: boolean('is_active').default(true).notNull(),\n\n  // Audit fields\n  created_by_id: text('created_by_id').references(() => users.id),\n  updated_by_id: text('updated_by_id').references(() => users.id),\n  deleted_at: timestamp('deleted_at'),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull()\n}, (table) => ({\n  slugIdx: uniqueIndex('idx_qapi_tags_slug').on(table.slug),\n  categoryIdx: index('idx_qapi_tags_category').on(table.category)\n}));\n\n/**\n * Metric Definitions Table\n * Flexible metric type definitions with extensible schema to accommodate new KPIs\n */\nexport const qapi_metric_definitions = pgTable('qapi_metric_definitions', {\n  id: bigint('id', { mode: 'number' }).primaryKey().generatedByDefaultAsIdentity(),\n\n  // Identification\n  name: varchar('name', { length: 255 }).notNull(),\n  code: varchar('code', { length: 100 }).notNull(),\n  description: text('description'),\n\n  // Classification\n  category: varchar('category', { length: 100 }).notNull(), // DEFECT_RATE, TEST_COVERAGE, MTTR, CUSTOMER_ISSUES, etc.\n  type: varchar('type', { length: 50 }).notNull(), // PERCENTAGE, COUNT, DURATION, RATIO, SCORE\n  unit: varchar('unit', { length: 50 }), // %, hours, count, etc.\n\n  // Data specifications\n  data_type: varchar('data_type', { length: 50 }).default('DECIMAL').notNull(), // DECIMAL, INTEGER, BOOLEAN\n  precision_digits: integer('precision_digits').default(2), // Decimal precision\n  aggregation_method: varchar('aggregation_method', { length: 50 }).default('AVG'), // AVG, SUM, MIN, MAX, LATEST, COUNT\n\n  // Calculation\n  calculation_formula: text('calculation_formula'), // Formula for calculated/derived metrics\n  numerator_definition: text('numerator_definition'),\n  denominator_definition: text('denominator_definition'),\n\n  // Product area\n  product_area_id: bigint('product_area_id', { mode: 'number' }).references(() => qapi_product_areas.id),\n\n  // Collection settings\n  collection_frequency: varchar('collection_frequency', { length: 50 }), // REAL_TIME, HOURLY, DAILY, WEEKLY, MONTHLY\n  data_source: varchar('data_source', { length: 100 }), // MANUAL, API, CI_CD, MONITORING, TEST_FRAMEWORK\n  source_system: varchar('source_system', { length: 255 }), // External system identifier\n\n  // Extensible attributes\n  custom_attributes: jsonb('custom_attributes'), // Flexible schema for metric-specific attributes\n\n  // Versioning for evolving metric definitions\n  definition_version: integer('definition_version').default(1).notNull(),\n  effective_date: date('effective_date'),\n  deprecation_date: date('deprecation_date'),\n\n  // Status\n  is_active: boolean('is_active').default(true).notNull(),\n  is_public: boolean('is_public').default(false), // For public reporting\n  is_cms_required: boolean('is_cms_required').default(false),\n\n  // Metadata\n  documentation_url: text('documentation_url'),\n  notes: text('notes'),\n  metadata: jsonb('metadata'),\n\n  // Audit fields\n  created_by_id: text('created_by_id').references(() => users.id),\n  updated_by_id: text('updated_by_id').references(() => users.id),\n  deleted_at: timestamp('deleted_at'),\n  deleted_by_id: text('deleted_by_id').references(() => users.id),\n  version: integer('version').default(1).notNull(),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull()\n}, (table) => ({\n  codeIdx: uniqueIndex('idx_qapi_metric_definitions_code').on(table.code),\n  categoryIdx: index('idx_qapi_metric_definitions_category').on(table.category),\n  productAreaIdx: index('idx_qapi_metric_definitions_product_area').on(table.product_area_id),\n  activeIdx: index('idx_qapi_metric_definitions_active').on(table.is_active)\n}));\n\n/**\n * Metric Thresholds Table\n * Threshold definitions for alerting and SLA tracking\n */\nexport const qapi_metric_thresholds = pgTable('qapi_metric_thresholds', {\n  id: bigint('id', { mode: 'number' }).primaryKey().generatedByDefaultAsIdentity(),\n  metric_definition_id: bigint('metric_definition_id', { mode: 'number' }).references(() => qapi_metric_definitions.id).notNull(),\n\n  // Threshold identification\n  name: varchar('name', { length: 255 }).notNull(),\n  description: text('description'),\n\n  // Threshold levels\n  threshold_type: varchar('threshold_type', { length: 50 }).notNull(), // WARNING, CRITICAL, SLA, TARGET, BASELINE\n  comparison_operator: varchar('comparison_operator', { length: 20 }).notNull(), // GT, GTE, LT, LTE, EQ, NEQ, BETWEEN\n\n  // Values\n  threshold_value: decimal('threshold_value', { precision: 18, scale: 4 }),\n  threshold_value_min: decimal('threshold_value_min', { precision: 18, scale: 4 }), // For BETWEEN operator\n  threshold_value_max: decimal('threshold_value_max', { precision: 18, scale: 4 }), // For BETWEEN operator\n\n  // Direction (for understanding improvement)\n  improvement_direction: varchar('improvement_direction', { length: 20 }), // HIGHER_IS_BETTER, LOWER_IS_BETTER\n\n  // Alert configuration\n  alert_enabled: boolean('alert_enabled').default(true).notNull(),\n  alert_priority: varchar('alert_priority', { length: 20 }).default('MEDIUM'), // LOW, MEDIUM, HIGH, CRITICAL\n  alert_message: text('alert_message'),\n  notification_channels: jsonb('notification_channels'), // [\"EMAIL\", \"SLACK\", \"WEBHOOK\"]\n  cooldown_minutes: integer('cooldown_minutes').default(60), // Prevent alert storms\n\n  // Context applicability\n  applicable_environments: jsonb('applicable_environments'), // [\"PRODUCTION\", \"STAGING\"]\n  applicable_teams: jsonb('applicable_teams'),\n\n  // Status\n  is_active: boolean('is_active').default(true).notNull(),\n  effective_date: date('effective_date'),\n  expiration_date: date('expiration_date'),\n\n  // Metadata\n  metadata: jsonb('metadata'),\n\n  // Audit fields\n  created_by_id: text('created_by_id').references(() => users.id),\n  updated_by_id: text('updated_by_id').references(() => users.id),\n  deleted_at: timestamp('deleted_at'),\n  version: integer('version').default(1).notNull(),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull()\n}, (table) => ({\n  metricIdx: index('idx_qapi_metric_thresholds_metric').on(table.metric_definition_id),\n  typeIdx: index('idx_qapi_metric_thresholds_type').on(table.threshold_type),\n  activeIdx: index('idx_qapi_metric_thresholds_active').on(table.is_active)\n}));\n\n/**\n * Metric Values Table\n * Time-series metric values with context (product area, environment, release version, team)\n */\nexport const qapi_metric_values = pgTable('qapi_metric_values', {\n  id: bigint('id', { mode: 'number' }).primaryKey().generatedByDefaultAsIdentity(),\n  metric_definition_id: bigint('metric_definition_id', { mode: 'number' }).references(() => qapi_metric_definitions.id).notNull(),\n\n  // Timestamp (granular for trend analysis)\n  recorded_at: timestamp('recorded_at').notNull(),\n  measurement_period_start: timestamp('measurement_period_start'),\n  measurement_period_end: timestamp('measurement_period_end'),\n\n  // Values\n  value: decimal('value', { precision: 18, scale: 4 }).notNull(),\n  numerator: decimal('numerator', { precision: 18, scale: 4 }),\n  denominator: decimal('denominator', { precision: 18, scale: 4 }),\n\n  // Context\n  product_area_id: bigint('product_area_id', { mode: 'number' }).references(() => qapi_product_areas.id),\n  environment: varchar('environment', { length: 50 }), // PRODUCTION, STAGING, DEVELOPMENT\n  release_version: varchar('release_version', { length: 100 }),\n  team: varchar('team', { length: 255 }),\n\n  // Data quality\n  is_validated: boolean('is_validated').default(false),\n  validated_by_id: text('validated_by_id').references(() => users.id),\n  validated_at: timestamp('validated_at'),\n\n  // Source tracking\n  data_source: varchar('data_source', { length: 100 }), // MANUAL, API, AUTOMATION\n  source_reference: varchar('source_reference', { length: 500 }), // External reference ID\n\n  // Threshold evaluation cache\n  meets_target: boolean('meets_target'),\n  threshold_status: varchar('threshold_status', { length: 50 }), // OK, WARNING, CRITICAL, SLA_BREACH\n\n  // Extended attributes\n  attributes: jsonb('attributes'),\n\n  // Metadata\n  notes: text('notes'),\n  metadata: jsonb('metadata'),\n\n  // Audit fields\n  created_by_id: text('created_by_id').references(() => users.id),\n  updated_by_id: text('updated_by_id').references(() => users.id),\n  deleted_at: timestamp('deleted_at'),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull()\n}, (table) => ({\n  metricTimeIdx: index('idx_qapi_metric_values_metric_time').on(table.metric_definition_id, table.recorded_at),\n  timeIdx: index('idx_qapi_metric_values_time').on(table.recorded_at),\n  productAreaTimeIdx: index('idx_qapi_metric_values_area_time').on(table.product_area_id, table.recorded_at),\n  teamTimeIdx: index('idx_qapi_metric_values_team_time').on(table.team, table.recorded_at),\n  thresholdStatusIdx: index('idx_qapi_metric_values_threshold').on(table.threshold_status)\n}));\n\n/**\n * Improvement Initiatives Table\n * Enhanced initiative tracking with lifecycle management, ownership, and documentation links\n */\nexport const qapi_improvement_initiatives = pgTable('qapi_improvement_initiatives', {\n  id: bigint('id', { mode: 'number' }).primaryKey().generatedByDefaultAsIdentity(),\n\n  // Identification\n  title: varchar('title', { length: 500 }).notNull(),\n  code: varchar('code', { length: 100 }),\n  description: text('description'),\n\n  // Classification\n  initiative_type: varchar('initiative_type', { length: 100 }), // QUALITY_IMPROVEMENT, DEFECT_REDUCTION, PROCESS_OPTIMIZATION, etc.\n  category: varchar('category', { length: 100 }), // CLINICAL, OPERATIONAL, TECHNICAL, COMPLIANCE\n  priority: varchar('priority', { length: 20 }).default('MEDIUM'), // LOW, MEDIUM, HIGH, CRITICAL\n\n  // Objectives\n  objectives: text('objectives'),\n  success_criteria: text('success_criteria'),\n  expected_impact: text('expected_impact'),\n\n  // Lifecycle status\n  status: varchar('status', { length: 50 }).default('PROPOSED').notNull(), // PROPOSED, APPROVED, IN_PROGRESS, COMPLETED, CANCELLED, ON_HOLD\n  status_reason: text('status_reason'),\n\n  // Ownership\n  owner_id: text('owner_id').references(() => users.id),\n  team: varchar('team', { length: 255 }),\n  department: varchar('department', { length: 255 }),\n  sponsor_id: text('sponsor_id').references(() => users.id),\n  contributors: jsonb('contributors'), // Array of user IDs or names\n\n  // Product area\n  product_area_id: bigint('product_area_id', { mode: 'number' }).references(() => qapi_product_areas.id),\n\n  // Timeline - Planned\n  planned_start_date: date('planned_start_date'),\n  planned_end_date: date('planned_end_date'),\n\n  // Timeline - Actual\n  actual_start_date: date('actual_start_date'),\n  actual_end_date: date('actual_end_date'),\n\n  // Progress tracking\n  progress_percentage: integer('progress_percentage').default(0),\n  milestones: jsonb('milestones'), // Array of milestone objects with status\n\n  // External links\n  documentation_url: text('documentation_url'),\n  ticket_references: jsonb('ticket_references'), // Links to JIRA, GitHub issues, etc.\n  project_management_url: text('project_management_url'),\n\n  // Impact assessment\n  resources_required: text('resources_required'),\n  estimated_cost: decimal('estimated_cost', { precision: 18, scale: 2 }),\n  actual_cost: decimal('actual_cost', { precision: 18, scale: 2 }),\n  roi_expected: decimal('roi_expected', { precision: 10, scale: 2 }),\n  roi_actual: decimal('roi_actual', { precision: 10, scale: 2 }),\n\n  // Results\n  outcomes: text('outcomes'),\n  lessons_learned: text('lessons_learned'),\n  follow_up_actions: text('follow_up_actions'),\n\n  // Approval\n  approved_by_id: text('approved_by_id').references(() => users.id),\n  approved_at: timestamp('approved_at'),\n  approval_notes: text('approval_notes'),\n\n  // Metadata\n  attachments: jsonb('attachments'),\n  notes: text('notes'),\n  metadata: jsonb('metadata'),\n\n  // Audit fields\n  created_by_id: text('created_by_id').references(() => users.id),\n  updated_by_id: text('updated_by_id').references(() => users.id),\n  deleted_at: timestamp('deleted_at'),\n  deleted_by_id: text('deleted_by_id').references(() => users.id),\n  version: integer('version').default(1).notNull(),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull()\n}, (table) => ({\n  codeIdx: uniqueIndex('idx_qapi_initiatives_code').on(table.code),\n  statusIdx: index('idx_qapi_initiatives_status').on(table.status),\n  ownerIdx: index('idx_qapi_initiatives_owner').on(table.owner_id),\n  productAreaIdx: index('idx_qapi_initiatives_product_area').on(table.product_area_id),\n  priorityStatusIdx: index('idx_qapi_initiatives_priority_status').on(table.priority, table.status),\n  dateRangeIdx: index('idx_qapi_initiatives_dates').on(table.planned_start_date, table.planned_end_date)\n}));\n\n/**\n * Initiative Metrics Table\n * Many-to-many relationship between metrics and initiatives\n */\nexport const qapi_initiative_metrics = pgTable('qapi_initiative_metrics', {\n  id: bigint('id', { mode: 'number' }).primaryKey().generatedByDefaultAsIdentity(),\n  initiative_id: bigint('initiative_id', { mode: 'number' }).references(() => qapi_improvement_initiatives.id).notNull(),\n  metric_definition_id: bigint('metric_definition_id', { mode: 'number' }).references(() => qapi_metric_definitions.id).notNull(),\n\n  // Relationship type\n  relationship_type: varchar('relationship_type', { length: 50 }).notNull(), // PRIMARY_TARGET, SECONDARY_TARGET, MONITORING, AFFECTED\n\n  // Impact tracking\n  target_improvement: decimal('target_improvement', { precision: 10, scale: 4 }), // Expected improvement percentage\n  actual_improvement: decimal('actual_improvement', { precision: 10, scale: 4 }),\n\n  // Correlation tracking\n  correlation_strength: decimal('correlation_strength', { precision: 5, scale: 4 }), // -1 to 1\n  correlation_notes: text('correlation_notes'),\n\n  // Status\n  is_active: boolean('is_active').default(true).notNull(),\n\n  // Metadata\n  notes: text('notes'),\n  metadata: jsonb('metadata'),\n\n  // Audit fields\n  created_by_id: text('created_by_id').references(() => users.id),\n  updated_by_id: text('updated_by_id').references(() => users.id),\n  deleted_at: timestamp('deleted_at'),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull()\n}, (table) => ({\n  initiativeIdx: index('idx_qapi_initiative_metrics_initiative').on(table.initiative_id),\n  metricIdx: index('idx_qapi_initiative_metrics_metric').on(table.metric_definition_id),\n  uniqueRelationshipIdx: uniqueIndex('idx_qapi_initiative_metrics_unique').on(table.initiative_id, table.metric_definition_id)\n}));\n\n/**\n * Metric Snapshots Table\n * Before/after metric snapshots to quantify initiative impact\n */\nexport const qapi_metric_snapshots = pgTable('qapi_metric_snapshots', {\n  id: bigint('id', { mode: 'number' }).primaryKey().generatedByDefaultAsIdentity(),\n  initiative_id: bigint('initiative_id', { mode: 'number' }).references(() => qapi_improvement_initiatives.id).notNull(),\n  metric_definition_id: bigint('metric_definition_id', { mode: 'number' }).references(() => qapi_metric_definitions.id).notNull(),\n\n  // Snapshot type\n  snapshot_type: varchar('snapshot_type', { length: 50 }).notNull(), // BASELINE, MIDPOINT, FINAL, CUSTOM\n  snapshot_name: varchar('snapshot_name', { length: 255 }),\n\n  // Timestamp\n  snapshot_date: date('snapshot_date').notNull(),\n  measurement_period_start: date('measurement_period_start'),\n  measurement_period_end: date('measurement_period_end'),\n\n  // Values\n  value: decimal('value', { precision: 18, scale: 4 }).notNull(),\n  numerator: decimal('numerator', { precision: 18, scale: 4 }),\n  denominator: decimal('denominator', { precision: 18, scale: 4 }),\n\n  // Comparison to baseline\n  baseline_value: decimal('baseline_value', { precision: 18, scale: 4 }),\n  absolute_change: decimal('absolute_change', { precision: 18, scale: 4 }),\n  percentage_change: decimal('percentage_change', { precision: 10, scale: 4 }),\n\n  // Statistical context\n  sample_size: integer('sample_size'),\n  standard_deviation: decimal('standard_deviation', { precision: 18, scale: 4 }),\n  confidence_interval: jsonb('confidence_interval'), // { lower: x, upper: y, level: 0.95 }\n\n  // Notes\n  analysis_notes: text('analysis_notes'),\n\n  // Metadata\n  metadata: jsonb('metadata'),\n\n  // Audit fields\n  created_by_id: text('created_by_id').references(() => users.id),\n  updated_by_id: text('updated_by_id').references(() => users.id),\n  deleted_at: timestamp('deleted_at'),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull()\n}, (table) => ({\n  initiativeIdx: index('idx_qapi_metric_snapshots_initiative').on(table.initiative_id),\n  metricIdx: index('idx_qapi_metric_snapshots_metric').on(table.metric_definition_id),\n  dateIdx: index('idx_qapi_metric_snapshots_date').on(table.snapshot_date)\n}));\n\n/**\n * Initiative Dependencies Table\n * Track initiative dependencies and prerequisites\n */\nexport const qapi_initiative_dependencies = pgTable('qapi_initiative_dependencies', {\n  id: bigint('id', { mode: 'number' }).primaryKey().generatedByDefaultAsIdentity(),\n  initiative_id: bigint('initiative_id', { mode: 'number' }).references(() => qapi_improvement_initiatives.id).notNull(),\n  depends_on_id: bigint('depends_on_id', { mode: 'number' }).references(() => qapi_improvement_initiatives.id).notNull(),\n\n  // Dependency type\n  dependency_type: varchar('dependency_type', { length: 50 }).notNull(), // BLOCKS, REQUIRES, RELATED, INFORMS\n\n  // Dependency details\n  description: text('description'),\n  is_required: boolean('is_required').default(true).notNull(),\n\n  // Status\n  is_active: boolean('is_active').default(true).notNull(),\n  is_resolved: boolean('is_resolved').default(false),\n  resolved_at: timestamp('resolved_at'),\n\n  // Metadata\n  metadata: jsonb('metadata'),\n\n  // Audit fields\n  created_by_id: text('created_by_id').references(() => users.id),\n  updated_by_id: text('updated_by_id').references(() => users.id),\n  deleted_at: timestamp('deleted_at'),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull()\n}, (table) => ({\n  initiativeIdx: index('idx_qapi_initiative_deps_initiative').on(table.initiative_id),\n  dependsOnIdx: index('idx_qapi_initiative_deps_depends_on').on(table.depends_on_id),\n  uniqueDependencyIdx: uniqueIndex('idx_qapi_initiative_deps_unique').on(table.initiative_id, table.depends_on_id)\n}));\n\n/**\n * Entity Tags Table\n * Many-to-many relationship for tagging various QAPI entities\n */\nexport const qapi_entity_tags = pgTable('qapi_entity_tags', {\n  id: bigint('id', { mode: 'number' }).primaryKey().generatedByDefaultAsIdentity(),\n  tag_id: bigint('tag_id', { mode: 'number' }).references(() => qapi_tags.id).notNull(),\n\n  // Entity reference (polymorphic)\n  entity_type: varchar('entity_type', { length: 100 }).notNull(), // METRIC, INITIATIVE, INCIDENT, GRIEVANCE, etc.\n  entity_id: bigint('entity_id', { mode: 'number' }).notNull(),\n\n  // Audit fields\n  created_by_id: text('created_by_id').references(() => users.id),\n  createdAt: timestamp('created_at').defaultNow().notNull()\n}, (table) => ({\n  tagIdx: index('idx_qapi_entity_tags_tag').on(table.tag_id),\n  entityIdx: index('idx_qapi_entity_tags_entity').on(table.entity_type, table.entity_id),\n  uniqueTagIdx: uniqueIndex('idx_qapi_entity_tags_unique').on(table.tag_id, table.entity_type, table.entity_id)\n}));\n\n/**\n * Metric Aggregations Table\n * Pre-computed summary data for dashboard performance (daily, weekly, monthly)\n */\nexport const qapi_metric_aggregations = pgTable('qapi_metric_aggregations', {\n  id: bigint('id', { mode: 'number' }).primaryKey().generatedByDefaultAsIdentity(),\n  metric_definition_id: bigint('metric_definition_id', { mode: 'number' }).references(() => qapi_metric_definitions.id).notNull(),\n\n  // Time period\n  aggregation_period: varchar('aggregation_period', { length: 20 }).notNull(), // DAILY, WEEKLY, MONTHLY, QUARTERLY, YEARLY\n  period_start: date('period_start').notNull(),\n  period_end: date('period_end').notNull(),\n\n  // Context\n  product_area_id: bigint('product_area_id', { mode: 'number' }).references(() => qapi_product_areas.id),\n  team: varchar('team', { length: 255 }),\n  environment: varchar('environment', { length: 50 }),\n\n  // Aggregated values\n  value_avg: decimal('value_avg', { precision: 18, scale: 4 }),\n  value_min: decimal('value_min', { precision: 18, scale: 4 }),\n  value_max: decimal('value_max', { precision: 18, scale: 4 }),\n  value_sum: decimal('value_sum', { precision: 18, scale: 4 }),\n  value_count: integer('value_count'),\n  value_stddev: decimal('value_stddev', { precision: 18, scale: 4 }),\n\n  // Trend\n  previous_period_value: decimal('previous_period_value', { precision: 18, scale: 4 }),\n  period_over_period_change: decimal('period_over_period_change', { precision: 10, scale: 4 }),\n  trend_direction: varchar('trend_direction', { length: 20 }), // IMPROVING, DECLINING, STABLE\n\n  // Threshold summary\n  target_met_count: integer('target_met_count').default(0),\n  warning_count: integer('warning_count').default(0),\n  critical_count: integer('critical_count').default(0),\n\n  // Refresh tracking\n  last_refreshed_at: timestamp('last_refreshed_at').notNull(),\n\n  // Metadata\n  metadata: jsonb('metadata'),\n\n  // Audit fields\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull()\n}, (table) => ({\n  metricPeriodIdx: index('idx_qapi_aggregations_metric_period').on(table.metric_definition_id, table.aggregation_period, table.period_start),\n  periodIdx: index('idx_qapi_aggregations_period').on(table.aggregation_period, table.period_start),\n  productAreaPeriodIdx: index('idx_qapi_aggregations_area_period').on(table.product_area_id, table.aggregation_period, table.period_start),\n  uniqueAggIdx: uniqueIndex('idx_qapi_aggregations_unique').on(\n    table.metric_definition_id,\n    table.aggregation_period,\n    table.period_start,\n    table.product_area_id,\n    table.team,\n    table.environment\n  )\n}));\n\n/**\n * Webhooks Table\n * Webhook configurations for threshold breach notifications\n */\nexport const qapi_webhooks = pgTable('qapi_webhooks', {\n  id: bigint('id', { mode: 'number' }).primaryKey().generatedByDefaultAsIdentity(),\n\n  // Configuration\n  name: varchar('name', { length: 255 }).notNull(),\n  description: text('description'),\n  url: text('url').notNull(),\n  http_method: varchar('http_method', { length: 10 }).default('POST').notNull(),\n\n  // Authentication\n  auth_type: varchar('auth_type', { length: 50 }), // NONE, BASIC, BEARER, API_KEY\n  auth_config: jsonb('auth_config'), // Encrypted auth configuration\n\n  // Headers\n  custom_headers: jsonb('custom_headers'),\n\n  // Payload configuration\n  payload_template: text('payload_template'), // Handlebars template for custom payloads\n  content_type: varchar('content_type', { length: 100 }).default('application/json'),\n\n  // Trigger settings\n  trigger_on: jsonb('trigger_on'), // [\"THRESHOLD_BREACH\", \"INITIATIVE_STATUS_CHANGE\", etc.]\n  filter_criteria: jsonb('filter_criteria'), // Specific metrics, thresholds, or initiatives\n\n  // Retry configuration\n  max_retries: integer('max_retries').default(3),\n  retry_delay_seconds: integer('retry_delay_seconds').default(60),\n  timeout_seconds: integer('timeout_seconds').default(30),\n\n  // Status\n  is_active: boolean('is_active').default(true).notNull(),\n  last_triggered_at: timestamp('last_triggered_at'),\n  last_success_at: timestamp('last_success_at'),\n  last_failure_at: timestamp('last_failure_at'),\n  consecutive_failures: integer('consecutive_failures').default(0),\n\n  // Metadata\n  notes: text('notes'),\n  metadata: jsonb('metadata'),\n\n  // Audit fields\n  created_by_id: text('created_by_id').references(() => users.id),\n  updated_by_id: text('updated_by_id').references(() => users.id),\n  deleted_at: timestamp('deleted_at'),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull()\n}, (table) => ({\n  activeIdx: index('idx_qapi_webhooks_active').on(table.is_active)\n}));\n\n/**\n * Webhook Events Table\n * Log of webhook events for debugging and audit\n */\nexport const qapi_webhook_events = pgTable('qapi_webhook_events', {\n  id: bigint('id', { mode: 'number' }).primaryKey().generatedByDefaultAsIdentity(),\n  webhook_id: bigint('webhook_id', { mode: 'number' }).references(() => qapi_webhooks.id).notNull(),\n\n  // Event details\n  event_type: varchar('event_type', { length: 100 }).notNull(),\n  triggered_at: timestamp('triggered_at').notNull(),\n\n  // Request\n  request_url: text('request_url'),\n  request_method: varchar('request_method', { length: 10 }),\n  request_headers: jsonb('request_headers'),\n  request_body: text('request_body'),\n\n  // Response\n  response_status: integer('response_status'),\n  response_headers: jsonb('response_headers'),\n  response_body: text('response_body'),\n  response_time_ms: integer('response_time_ms'),\n\n  // Status\n  success: boolean('success').notNull(),\n  error_message: text('error_message'),\n  retry_count: integer('retry_count').default(0),\n\n  // Context\n  trigger_context: jsonb('trigger_context'), // What triggered this event\n\n  // Metadata\n  metadata: jsonb('metadata'),\n\n  // Timestamp\n  createdAt: timestamp('created_at').defaultNow().notNull()\n}, (table) => ({\n  webhookIdx: index('idx_qapi_webhook_events_webhook').on(table.webhook_id),\n  triggeredIdx: index('idx_qapi_webhook_events_triggered').on(table.triggered_at),\n  successIdx: index('idx_qapi_webhook_events_success').on(table.success)\n}));\n\n/**\n * QAPI Change Log Table\n * Comprehensive audit trail for all QAPI-related changes\n */\nexport const qapi_change_log = pgTable('qapi_change_log', {\n  id: bigint('id', { mode: 'number' }).primaryKey().generatedByDefaultAsIdentity(),\n\n  // Entity reference\n  entity_type: varchar('entity_type', { length: 100 }).notNull(), // METRIC_DEFINITION, METRIC_VALUE, INITIATIVE, THRESHOLD, etc.\n  entity_id: bigint('entity_id', { mode: 'number' }).notNull(),\n\n  // Change details\n  action: varchar('action', { length: 50 }).notNull(), // CREATE, UPDATE, DELETE, RESTORE, STATUS_CHANGE\n  changes: jsonb('changes'), // { field: { old: x, new: y } }\n  change_summary: text('change_summary'),\n\n  // User attribution\n  changed_by_id: text('changed_by_id').references(() => users.id).notNull(),\n  changed_by_name: varchar('changed_by_name', { length: 255 }),\n  changed_by_role: varchar('changed_by_role', { length: 100 }),\n\n  // Context\n  change_reason: text('change_reason'),\n  ip_address: varchar('ip_address', { length: 45 }),\n  user_agent: text('user_agent'),\n  session_id: varchar('session_id', { length: 255 }),\n\n  // Compliance\n  requires_review: boolean('requires_review').default(false),\n  reviewed_by_id: text('reviewed_by_id').references(() => users.id),\n  reviewed_at: timestamp('reviewed_at'),\n\n  // Timestamp (with timezone for audit compliance)\n  changed_at: timestamp('changed_at').defaultNow().notNull(),\n\n  // Metadata\n  metadata: jsonb('metadata')\n}, (table) => ({\n  entityIdx: index('idx_qapi_change_log_entity').on(table.entity_type, table.entity_id),\n  userIdx: index('idx_qapi_change_log_user').on(table.changed_by_id),\n  timeIdx: index('idx_qapi_change_log_time').on(table.changed_at),\n  actionIdx: index('idx_qapi_change_log_action').on(table.action)\n}));\n"
}

Now let me add the export to the schema index file.

ðŸ”§ Tool: Edit
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/db/schemas/index.js",
  "old_string": "export * from './qapi.schema.js';",
  "new_string": "export * from './qapi.schema.js';\nexport * from './qapiMetrics.schema.js';"
}

ðŸ”§ Tool: TodoWrite
Input: {
  "todos": [
    {
      "content": "Explore existing codebase structure and patterns",
      "status": "completed",
      "activeForm": "Exploring existing codebase structure and patterns"
    },
    {
      "content": "Design additional QAPI schema tables for comprehensive metrics tracking",
      "status": "completed",
      "activeForm": "Designing additional QAPI schema tables for comprehensive metrics tracking"
    },
    {
      "content": "Implement enhanced schema with metrics, thresholds, alerts, and initiative tracking",
      "status": "completed",
      "activeForm": "Implementing enhanced schema with metrics, thresholds, alerts, and initiative tracking"
    },
    {
      "content": "Create/update controllers for QAPI endpoints",
      "status": "in_progress",
      "activeForm": "Creating/updating controllers for QAPI endpoints"
    },
    {
      "content": "Create/update routes for QAPI endpoints",
      "status": "pending",
      "activeForm": "Creating/updating routes for QAPI endpoints"
    },
    {
      "content": "Create migration file",
      "status": "pending",
      "activeForm": "Creating migration file"
    },
    {
      "content": "Register new routes in api.routes.js",
      "status": "pending",
      "activeForm": "Registering new routes in api.routes.js"
    },
    {
      "content": "Verify implementation with Playwright",
      "status": "pending",
      "activeForm": "Verifying implementation with Playwright"
    }
  ]
}

Now I need to create a controller for the new QAPI metrics functionality. I'll create a new controller file for the comprehensive metrics and initiatives.

ðŸ”§ Tool: Write
Input: {
  "file_path": "/Users/fabrice/Sites/chartwarden/Chartwarden/services/api/src/controllers/QAPIMetrics.controller.js",
  "content": "import { db } from \"../config/db.drizzle.js\";\nimport {\n  qapi_product_areas,\n  qapi_tags,\n  qapi_metric_definitions,\n  qapi_metric_thresholds,\n  qapi_metric_values,\n  qapi_improvement_initiatives,\n  qapi_initiative_metrics,\n  qapi_metric_snapshots,\n  qapi_initiative_dependencies,\n  qapi_entity_tags,\n  qapi_metric_aggregations,\n  qapi_webhooks,\n  qapi_webhook_events,\n  qapi_change_log\n} from \"../db/schemas/qapiMetrics.schema.js\";\nimport { eq, and, isNull, desc, asc, gte, lte, sql, or, inArray, ilike } from \"drizzle-orm\";\n\n/**\n * QAPI Metrics Controller\n * Manages comprehensive quality assurance metrics, thresholds, initiatives, and performance tracking\n */\nclass QAPIMetricsController {\n\n  // ==================== PRODUCT AREAS MANAGEMENT ====================\n\n  /**\n   * Get all product areas with optional hierarchy\n   */\n  async getAllProductAreas(request, reply) {\n    try {\n      const { parent_id, include_inactive } = request.query;\n\n      let conditions = [];\n\n      if (!include_inactive) {\n        conditions.push(eq(qapi_product_areas.is_active, true));\n      }\n      conditions.push(isNull(qapi_product_areas.deleted_at));\n\n      if (parent_id !== undefined) {\n        if (parent_id === 'null' || parent_id === '') {\n          conditions.push(isNull(qapi_product_areas.parent_id));\n        } else {\n          conditions.push(eq(qapi_product_areas.parent_id, parseInt(parent_id)));\n        }\n      }\n\n      const result = await db\n        .select()\n        .from(qapi_product_areas)\n        .where(and(...conditions))\n        .orderBy(asc(qapi_product_areas.level), asc(qapi_product_areas.name));\n\n      return {\n        status: 200,\n        message: \"Product areas retrieved successfully\",\n        data: result\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to retrieve product areas\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Get product area by ID\n   */\n  async getProductAreaById(request, reply) {\n    try {\n      const { id } = request.params;\n\n      const result = await db\n        .select()\n        .from(qapi_product_areas)\n        .where(and(\n          eq(qapi_product_areas.id, parseInt(id)),\n          isNull(qapi_product_areas.deleted_at)\n        ));\n\n      if (result.length === 0) {\n        reply.code(404);\n        return { status: 404, message: \"Product area not found\" };\n      }\n\n      return {\n        status: 200,\n        message: \"Product area retrieved successfully\",\n        data: result[0]\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to retrieve product area\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Create product area\n   */\n  async createProductArea(request, reply) {\n    try {\n      const data = request.body;\n\n      // Calculate path if parent exists\n      let path = `/${data.code}`;\n      let level = 0;\n\n      if (data.parent_id) {\n        const parent = await db\n          .select()\n          .from(qapi_product_areas)\n          .where(eq(qapi_product_areas.id, data.parent_id));\n\n        if (parent.length > 0) {\n          path = `${parent[0].path}/${data.code}`;\n          level = (parent[0].level || 0) + 1;\n        }\n      }\n\n      const result = await db\n        .insert(qapi_product_areas)\n        .values({\n          ...data,\n          path,\n          level,\n          created_by_id: request.user?.id\n        })\n        .returning();\n\n      await this._logChange(request, 'PRODUCT_AREA', result[0].id, 'CREATE', null, result[0]);\n\n      reply.code(201);\n      return {\n        status: 201,\n        message: \"Product area created successfully\",\n        data: result[0]\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to create product area\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Update product area\n   */\n  async updateProductArea(request, reply) {\n    try {\n      const { id } = request.params;\n      const data = request.body;\n\n      // Get existing for audit log\n      const existing = await db\n        .select()\n        .from(qapi_product_areas)\n        .where(eq(qapi_product_areas.id, parseInt(id)));\n\n      if (existing.length === 0) {\n        reply.code(404);\n        return { status: 404, message: \"Product area not found\" };\n      }\n\n      const result = await db\n        .update(qapi_product_areas)\n        .set({\n          ...data,\n          version: sql`${qapi_product_areas.version} + 1`,\n          updated_by_id: request.user?.id,\n          updatedAt: new Date()\n        })\n        .where(and(\n          eq(qapi_product_areas.id, parseInt(id)),\n          isNull(qapi_product_areas.deleted_at)\n        ))\n        .returning();\n\n      if (result.length === 0) {\n        reply.code(404);\n        return { status: 404, message: \"Product area not found\" };\n      }\n\n      await this._logChange(request, 'PRODUCT_AREA', parseInt(id), 'UPDATE', existing[0], result[0]);\n\n      return {\n        status: 200,\n        message: \"Product area updated successfully\",\n        data: result[0]\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to update product area\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Delete product area (soft delete)\n   */\n  async deleteProductArea(request, reply) {\n    try {\n      const { id } = request.params;\n\n      const result = await db\n        .update(qapi_product_areas)\n        .set({\n          deleted_at: new Date(),\n          deleted_by_id: request.user?.id,\n          updated_by_id: request.user?.id\n        })\n        .where(and(\n          eq(qapi_product_areas.id, parseInt(id)),\n          isNull(qapi_product_areas.deleted_at)\n        ))\n        .returning();\n\n      if (result.length === 0) {\n        reply.code(404);\n        return { status: 404, message: \"Product area not found\" };\n      }\n\n      await this._logChange(request, 'PRODUCT_AREA', parseInt(id), 'DELETE', result[0], null);\n\n      return {\n        status: 200,\n        message: \"Product area deleted successfully\"\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to delete product area\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  // ==================== TAGS MANAGEMENT ====================\n\n  /**\n   * Get all tags\n   */\n  async getAllTags(request, reply) {\n    try {\n      const { category, include_inactive } = request.query;\n\n      let conditions = [isNull(qapi_tags.deleted_at)];\n\n      if (!include_inactive) {\n        conditions.push(eq(qapi_tags.is_active, true));\n      }\n      if (category) {\n        conditions.push(eq(qapi_tags.category, category));\n      }\n\n      const result = await db\n        .select()\n        .from(qapi_tags)\n        .where(and(...conditions))\n        .orderBy(asc(qapi_tags.category), asc(qapi_tags.name));\n\n      return {\n        status: 200,\n        message: \"Tags retrieved successfully\",\n        data: result\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to retrieve tags\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Create tag\n   */\n  async createTag(request, reply) {\n    try {\n      const data = request.body;\n\n      // Generate slug if not provided\n      if (!data.slug) {\n        data.slug = data.name.toLowerCase().replace(/[^a-z0-9]+/g, '-');\n      }\n\n      const result = await db\n        .insert(qapi_tags)\n        .values({\n          ...data,\n          created_by_id: request.user?.id\n        })\n        .returning();\n\n      reply.code(201);\n      return {\n        status: 201,\n        message: \"Tag created successfully\",\n        data: result[0]\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to create tag\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  // ==================== METRIC DEFINITIONS MANAGEMENT ====================\n\n  /**\n   * Get all metric definitions\n   */\n  async getAllMetricDefinitions(request, reply) {\n    try {\n      const { category, product_area_id, include_inactive, search } = request.query;\n\n      let conditions = [isNull(qapi_metric_definitions.deleted_at)];\n\n      if (!include_inactive) {\n        conditions.push(eq(qapi_metric_definitions.is_active, true));\n      }\n      if (category) {\n        conditions.push(eq(qapi_metric_definitions.category, category));\n      }\n      if (product_area_id) {\n        conditions.push(eq(qapi_metric_definitions.product_area_id, parseInt(product_area_id)));\n      }\n      if (search) {\n        conditions.push(or(\n          ilike(qapi_metric_definitions.name, `%${search}%`),\n          ilike(qapi_metric_definitions.code, `%${search}%`),\n          ilike(qapi_metric_definitions.description, `%${search}%`)\n        ));\n      }\n\n      const result = await db\n        .select()\n        .from(qapi_metric_definitions)\n        .where(and(...conditions))\n        .orderBy(asc(qapi_metric_definitions.category), asc(qapi_metric_definitions.name));\n\n      return {\n        status: 200,\n        message: \"Metric definitions retrieved successfully\",\n        data: result,\n        count: result.length\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to retrieve metric definitions\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Get metric definition by ID\n   */\n  async getMetricDefinitionById(request, reply) {\n    try {\n      const { id } = request.params;\n\n      const result = await db\n        .select()\n        .from(qapi_metric_definitions)\n        .where(and(\n          eq(qapi_metric_definitions.id, parseInt(id)),\n          isNull(qapi_metric_definitions.deleted_at)\n        ));\n\n      if (result.length === 0) {\n        reply.code(404);\n        return { status: 404, message: \"Metric definition not found\" };\n      }\n\n      // Also get associated thresholds\n      const thresholds = await db\n        .select()\n        .from(qapi_metric_thresholds)\n        .where(and(\n          eq(qapi_metric_thresholds.metric_definition_id, parseInt(id)),\n          isNull(qapi_metric_thresholds.deleted_at),\n          eq(qapi_metric_thresholds.is_active, true)\n        ));\n\n      return {\n        status: 200,\n        message: \"Metric definition retrieved successfully\",\n        data: {\n          ...result[0],\n          thresholds\n        }\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to retrieve metric definition\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Create metric definition\n   */\n  async createMetricDefinition(request, reply) {\n    try {\n      const data = request.body;\n\n      const result = await db\n        .insert(qapi_metric_definitions)\n        .values({\n          ...data,\n          created_by_id: request.user?.id\n        })\n        .returning();\n\n      await this._logChange(request, 'METRIC_DEFINITION', result[0].id, 'CREATE', null, result[0]);\n\n      reply.code(201);\n      return {\n        status: 201,\n        message: \"Metric definition created successfully\",\n        data: result[0]\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to create metric definition\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Update metric definition\n   */\n  async updateMetricDefinition(request, reply) {\n    try {\n      const { id } = request.params;\n      const data = request.body;\n\n      const existing = await db\n        .select()\n        .from(qapi_metric_definitions)\n        .where(eq(qapi_metric_definitions.id, parseInt(id)));\n\n      if (existing.length === 0) {\n        reply.code(404);\n        return { status: 404, message: \"Metric definition not found\" };\n      }\n\n      const result = await db\n        .update(qapi_metric_definitions)\n        .set({\n          ...data,\n          version: sql`${qapi_metric_definitions.version} + 1`,\n          updated_by_id: request.user?.id,\n          updatedAt: new Date()\n        })\n        .where(and(\n          eq(qapi_metric_definitions.id, parseInt(id)),\n          isNull(qapi_metric_definitions.deleted_at)\n        ))\n        .returning();\n\n      if (result.length === 0) {\n        reply.code(404);\n        return { status: 404, message: \"Metric definition not found\" };\n      }\n\n      await this._logChange(request, 'METRIC_DEFINITION', parseInt(id), 'UPDATE', existing[0], result[0]);\n\n      return {\n        status: 200,\n        message: \"Metric definition updated successfully\",\n        data: result[0]\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to update metric definition\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Delete metric definition (soft delete)\n   */\n  async deleteMetricDefinition(request, reply) {\n    try {\n      const { id } = request.params;\n\n      const result = await db\n        .update(qapi_metric_definitions)\n        .set({\n          deleted_at: new Date(),\n          deleted_by_id: request.user?.id,\n          updated_by_id: request.user?.id\n        })\n        .where(and(\n          eq(qapi_metric_definitions.id, parseInt(id)),\n          isNull(qapi_metric_definitions.deleted_at)\n        ))\n        .returning();\n\n      if (result.length === 0) {\n        reply.code(404);\n        return { status: 404, message: \"Metric definition not found\" };\n      }\n\n      await this._logChange(request, 'METRIC_DEFINITION', parseInt(id), 'DELETE', result[0], null);\n\n      return {\n        status: 200,\n        message: \"Metric definition deleted successfully\"\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to delete metric definition\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  // ==================== METRIC THRESHOLDS MANAGEMENT ====================\n\n  /**\n   * Get thresholds for a metric\n   */\n  async getMetricThresholds(request, reply) {\n    try {\n      const { metric_id } = request.params;\n\n      const result = await db\n        .select()\n        .from(qapi_metric_thresholds)\n        .where(and(\n          eq(qapi_metric_thresholds.metric_definition_id, parseInt(metric_id)),\n          isNull(qapi_metric_thresholds.deleted_at)\n        ))\n        .orderBy(asc(qapi_metric_thresholds.threshold_type));\n\n      return {\n        status: 200,\n        message: \"Metric thresholds retrieved successfully\",\n        data: result\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to retrieve metric thresholds\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Create metric threshold\n   */\n  async createMetricThreshold(request, reply) {\n    try {\n      const data = request.body;\n\n      const result = await db\n        .insert(qapi_metric_thresholds)\n        .values({\n          ...data,\n          created_by_id: request.user?.id\n        })\n        .returning();\n\n      await this._logChange(request, 'METRIC_THRESHOLD', result[0].id, 'CREATE', null, result[0]);\n\n      reply.code(201);\n      return {\n        status: 201,\n        message: \"Metric threshold created successfully\",\n        data: result[0]\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to create metric threshold\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Update metric threshold\n   */\n  async updateMetricThreshold(request, reply) {\n    try {\n      const { id } = request.params;\n      const data = request.body;\n\n      const result = await db\n        .update(qapi_metric_thresholds)\n        .set({\n          ...data,\n          version: sql`${qapi_metric_thresholds.version} + 1`,\n          updated_by_id: request.user?.id,\n          updatedAt: new Date()\n        })\n        .where(and(\n          eq(qapi_metric_thresholds.id, parseInt(id)),\n          isNull(qapi_metric_thresholds.deleted_at)\n        ))\n        .returning();\n\n      if (result.length === 0) {\n        reply.code(404);\n        return { status: 404, message: \"Metric threshold not found\" };\n      }\n\n      return {\n        status: 200,\n        message: \"Metric threshold updated successfully\",\n        data: result[0]\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to update metric threshold\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Delete metric threshold (soft delete)\n   */\n  async deleteMetricThreshold(request, reply) {\n    try {\n      const { id } = request.params;\n\n      const result = await db\n        .update(qapi_metric_thresholds)\n        .set({\n          deleted_at: new Date(),\n          updated_by_id: request.user?.id\n        })\n        .where(and(\n          eq(qapi_metric_thresholds.id, parseInt(id)),\n          isNull(qapi_metric_thresholds.deleted_at)\n        ))\n        .returning();\n\n      if (result.length === 0) {\n        reply.code(404);\n        return { status: 404, message: \"Metric threshold not found\" };\n      }\n\n      return {\n        status: 200,\n        message: \"Metric threshold deleted successfully\"\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to delete metric threshold\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  // ==================== METRIC VALUES MANAGEMENT ====================\n\n  /**\n   * Record metric value (time-series data point)\n   */\n  async recordMetricValue(request, reply) {\n    try {\n      const data = request.body;\n\n      // Evaluate thresholds if metric has them\n      let thresholdStatus = null;\n      let meetsTarget = null;\n\n      if (data.metric_definition_id) {\n        const thresholds = await db\n          .select()\n          .from(qapi_metric_thresholds)\n          .where(and(\n            eq(qapi_metric_thresholds.metric_definition_id, data.metric_definition_id),\n            eq(qapi_metric_thresholds.is_active, true),\n            isNull(qapi_metric_thresholds.deleted_at)\n          ));\n\n        const evaluation = this._evaluateThresholds(data.value, thresholds);\n        thresholdStatus = evaluation.status;\n        meetsTarget = evaluation.meetsTarget;\n\n        // Check if we need to trigger webhooks\n        if (evaluation.breached) {\n          await this._triggerThresholdWebhooks(data.metric_definition_id, data.value, evaluation);\n        }\n      }\n\n      const result = await db\n        .insert(qapi_metric_values)\n        .values({\n          ...data,\n          recorded_at: data.recorded_at || new Date(),\n          threshold_status: thresholdStatus,\n          meets_target: meetsTarget,\n          created_by_id: request.user?.id\n        })\n        .returning();\n\n      reply.code(201);\n      return {\n        status: 201,\n        message: \"Metric value recorded successfully\",\n        data: result[0]\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to record metric value\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Get metric values (time-series data)\n   */\n  async getMetricValues(request, reply) {\n    try {\n      const { metric_id, product_area_id, team, environment, from_date, to_date, limit = 1000 } = request.query;\n\n      let conditions = [isNull(qapi_metric_values.deleted_at)];\n\n      if (metric_id) {\n        conditions.push(eq(qapi_metric_values.metric_definition_id, parseInt(metric_id)));\n      }\n      if (product_area_id) {\n        conditions.push(eq(qapi_metric_values.product_area_id, parseInt(product_area_id)));\n      }\n      if (team) {\n        conditions.push(eq(qapi_metric_values.team, team));\n      }\n      if (environment) {\n        conditions.push(eq(qapi_metric_values.environment, environment));\n      }\n      if (from_date) {\n        conditions.push(gte(qapi_metric_values.recorded_at, new Date(from_date)));\n      }\n      if (to_date) {\n        conditions.push(lte(qapi_metric_values.recorded_at, new Date(to_date)));\n      }\n\n      const result = await db\n        .select()\n        .from(qapi_metric_values)\n        .where(and(...conditions))\n        .orderBy(desc(qapi_metric_values.recorded_at))\n        .limit(parseInt(limit));\n\n      return {\n        status: 200,\n        message: \"Metric values retrieved successfully\",\n        data: result,\n        count: result.length\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to retrieve metric values\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Get metric aggregations (pre-computed summaries)\n   */\n  async getMetricAggregations(request, reply) {\n    try {\n      const { metric_id, product_area_id, period, from_date, to_date } = request.query;\n\n      let conditions = [];\n\n      if (metric_id) {\n        conditions.push(eq(qapi_metric_aggregations.metric_definition_id, parseInt(metric_id)));\n      }\n      if (product_area_id) {\n        conditions.push(eq(qapi_metric_aggregations.product_area_id, parseInt(product_area_id)));\n      }\n      if (period) {\n        conditions.push(eq(qapi_metric_aggregations.aggregation_period, period));\n      }\n      if (from_date) {\n        conditions.push(gte(qapi_metric_aggregations.period_start, from_date));\n      }\n      if (to_date) {\n        conditions.push(lte(qapi_metric_aggregations.period_end, to_date));\n      }\n\n      const result = await db\n        .select()\n        .from(qapi_metric_aggregations)\n        .where(conditions.length > 0 ? and(...conditions) : undefined)\n        .orderBy(desc(qapi_metric_aggregations.period_start));\n\n      return {\n        status: 200,\n        message: \"Metric aggregations retrieved successfully\",\n        data: result\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to retrieve metric aggregations\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  // ==================== IMPROVEMENT INITIATIVES MANAGEMENT ====================\n\n  /**\n   * Get all improvement initiatives\n   */\n  async getAllInitiatives(request, reply) {\n    try {\n      const { status, priority, owner_id, product_area_id, search } = request.query;\n\n      let conditions = [isNull(qapi_improvement_initiatives.deleted_at)];\n\n      if (status) {\n        conditions.push(eq(qapi_improvement_initiatives.status, status));\n      }\n      if (priority) {\n        conditions.push(eq(qapi_improvement_initiatives.priority, priority));\n      }\n      if (owner_id) {\n        conditions.push(eq(qapi_improvement_initiatives.owner_id, owner_id));\n      }\n      if (product_area_id) {\n        conditions.push(eq(qapi_improvement_initiatives.product_area_id, parseInt(product_area_id)));\n      }\n      if (search) {\n        conditions.push(or(\n          ilike(qapi_improvement_initiatives.title, `%${search}%`),\n          ilike(qapi_improvement_initiatives.description, `%${search}%`),\n          ilike(qapi_improvement_initiatives.code, `%${search}%`)\n        ));\n      }\n\n      const result = await db\n        .select()\n        .from(qapi_improvement_initiatives)\n        .where(and(...conditions))\n        .orderBy(desc(qapi_improvement_initiatives.createdAt));\n\n      return {\n        status: 200,\n        message: \"Initiatives retrieved successfully\",\n        data: result,\n        count: result.length\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to retrieve initiatives\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Get initiative by ID with related data\n   */\n  async getInitiativeById(request, reply) {\n    try {\n      const { id } = request.params;\n\n      const result = await db\n        .select()\n        .from(qapi_improvement_initiatives)\n        .where(and(\n          eq(qapi_improvement_initiatives.id, parseInt(id)),\n          isNull(qapi_improvement_initiatives.deleted_at)\n        ));\n\n      if (result.length === 0) {\n        reply.code(404);\n        return { status: 404, message: \"Initiative not found\" };\n      }\n\n      // Get linked metrics\n      const linkedMetrics = await db\n        .select({\n          relationship: qapi_initiative_metrics,\n          metric: qapi_metric_definitions\n        })\n        .from(qapi_initiative_metrics)\n        .leftJoin(qapi_metric_definitions, eq(qapi_initiative_metrics.metric_definition_id, qapi_metric_definitions.id))\n        .where(and(\n          eq(qapi_initiative_metrics.initiative_id, parseInt(id)),\n          isNull(qapi_initiative_metrics.deleted_at)\n        ));\n\n      // Get dependencies\n      const dependencies = await db\n        .select()\n        .from(qapi_initiative_dependencies)\n        .where(and(\n          eq(qapi_initiative_dependencies.initiative_id, parseInt(id)),\n          isNull(qapi_initiative_dependencies.deleted_at)\n        ));\n\n      // Get dependents (initiatives that depend on this one)\n      const dependents = await db\n        .select()\n        .from(qapi_initiative_dependencies)\n        .where(and(\n          eq(qapi_initiative_dependencies.depends_on_id, parseInt(id)),\n          isNull(qapi_initiative_dependencies.deleted_at)\n        ));\n\n      // Get snapshots\n      const snapshots = await db\n        .select()\n        .from(qapi_metric_snapshots)\n        .where(and(\n          eq(qapi_metric_snapshots.initiative_id, parseInt(id)),\n          isNull(qapi_metric_snapshots.deleted_at)\n        ))\n        .orderBy(asc(qapi_metric_snapshots.snapshot_date));\n\n      return {\n        status: 200,\n        message: \"Initiative retrieved successfully\",\n        data: {\n          ...result[0],\n          linkedMetrics,\n          dependencies,\n          dependents,\n          snapshots\n        }\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to retrieve initiative\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Create improvement initiative\n   */\n  async createInitiative(request, reply) {\n    try {\n      const data = request.body;\n\n      const result = await db\n        .insert(qapi_improvement_initiatives)\n        .values({\n          ...data,\n          created_by_id: request.user?.id\n        })\n        .returning();\n\n      await this._logChange(request, 'INITIATIVE', result[0].id, 'CREATE', null, result[0]);\n\n      reply.code(201);\n      return {\n        status: 201,\n        message: \"Initiative created successfully\",\n        data: result[0]\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to create initiative\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Update initiative\n   */\n  async updateInitiative(request, reply) {\n    try {\n      const { id } = request.params;\n      const data = request.body;\n\n      const existing = await db\n        .select()\n        .from(qapi_improvement_initiatives)\n        .where(eq(qapi_improvement_initiatives.id, parseInt(id)));\n\n      if (existing.length === 0) {\n        reply.code(404);\n        return { status: 404, message: \"Initiative not found\" };\n      }\n\n      // If status is changing, log it separately\n      const statusChanged = data.status && data.status !== existing[0].status;\n\n      const result = await db\n        .update(qapi_improvement_initiatives)\n        .set({\n          ...data,\n          version: sql`${qapi_improvement_initiatives.version} + 1`,\n          updated_by_id: request.user?.id,\n          updatedAt: new Date()\n        })\n        .where(and(\n          eq(qapi_improvement_initiatives.id, parseInt(id)),\n          isNull(qapi_improvement_initiatives.deleted_at)\n        ))\n        .returning();\n\n      if (result.length === 0) {\n        reply.code(404);\n        return { status: 404, message: \"Initiative not found\" };\n      }\n\n      const action = statusChanged ? 'STATUS_CHANGE' : 'UPDATE';\n      await this._logChange(request, 'INITIATIVE', parseInt(id), action, existing[0], result[0]);\n\n      return {\n        status: 200,\n        message: \"Initiative updated successfully\",\n        data: result[0]\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to update initiative\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Approve initiative\n   */\n  async approveInitiative(request, reply) {\n    try {\n      const { id } = request.params;\n      const { approval_notes } = request.body;\n\n      const result = await db\n        .update(qapi_improvement_initiatives)\n        .set({\n          status: 'APPROVED',\n          approved_by_id: request.user?.id,\n          approved_at: new Date(),\n          approval_notes,\n          version: sql`${qapi_improvement_initiatives.version} + 1`,\n          updated_by_id: request.user?.id,\n          updatedAt: new Date()\n        })\n        .where(and(\n          eq(qapi_improvement_initiatives.id, parseInt(id)),\n          eq(qapi_improvement_initiatives.status, 'PROPOSED'),\n          isNull(qapi_improvement_initiatives.deleted_at)\n        ))\n        .returning();\n\n      if (result.length === 0) {\n        reply.code(404);\n        return { status: 404, message: \"Initiative not found or not in PROPOSED status\" };\n      }\n\n      await this._logChange(request, 'INITIATIVE', parseInt(id), 'STATUS_CHANGE', { status: 'PROPOSED' }, result[0]);\n\n      return {\n        status: 200,\n        message: \"Initiative approved successfully\",\n        data: result[0]\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to approve initiative\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Delete initiative (soft delete)\n   */\n  async deleteInitiative(request, reply) {\n    try {\n      const { id } = request.params;\n\n      const result = await db\n        .update(qapi_improvement_initiatives)\n        .set({\n          deleted_at: new Date(),\n          deleted_by_id: request.user?.id,\n          updated_by_id: request.user?.id\n        })\n        .where(and(\n          eq(qapi_improvement_initiatives.id, parseInt(id)),\n          isNull(qapi_improvement_initiatives.deleted_at)\n        ))\n        .returning();\n\n      if (result.length === 0) {\n        reply.code(404);\n        return { status: 404, message: \"Initiative not found\" };\n      }\n\n      await this._logChange(request, 'INITIATIVE', parseInt(id), 'DELETE', result[0], null);\n\n      return {\n        status: 200,\n        message: \"Initiative deleted successfully\"\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to delete initiative\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  // ==================== INITIATIVE METRICS LINKING ====================\n\n  /**\n   * Link metric to initiative\n   */\n  async linkMetricToInitiative(request, reply) {\n    try {\n      const data = request.body;\n\n      const result = await db\n        .insert(qapi_initiative_metrics)\n        .values({\n          ...data,\n          created_by_id: request.user?.id\n        })\n        .returning();\n\n      reply.code(201);\n      return {\n        status: 201,\n        message: \"Metric linked to initiative successfully\",\n        data: result[0]\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to link metric to initiative\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Unlink metric from initiative\n   */\n  async unlinkMetricFromInitiative(request, reply) {\n    try {\n      const { id } = request.params;\n\n      const result = await db\n        .update(qapi_initiative_metrics)\n        .set({\n          deleted_at: new Date(),\n          updated_by_id: request.user?.id\n        })\n        .where(and(\n          eq(qapi_initiative_metrics.id, parseInt(id)),\n          isNull(qapi_initiative_metrics.deleted_at)\n        ))\n        .returning();\n\n      if (result.length === 0) {\n        reply.code(404);\n        return { status: 404, message: \"Metric link not found\" };\n      }\n\n      return {\n        status: 200,\n        message: \"Metric unlinked from initiative successfully\"\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to unlink metric from initiative\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  // ==================== METRIC SNAPSHOTS ====================\n\n  /**\n   * Create metric snapshot for initiative\n   */\n  async createMetricSnapshot(request, reply) {\n    try {\n      const data = request.body;\n\n      // Calculate changes from baseline if applicable\n      let absoluteChange = null;\n      let percentageChange = null;\n\n      if (data.baseline_value && data.value) {\n        absoluteChange = parseFloat(data.value) - parseFloat(data.baseline_value);\n        if (parseFloat(data.baseline_value) !== 0) {\n          percentageChange = (absoluteChange / parseFloat(data.baseline_value)) * 100;\n        }\n      }\n\n      const result = await db\n        .insert(qapi_metric_snapshots)\n        .values({\n          ...data,\n          absolute_change: absoluteChange,\n          percentage_change: percentageChange,\n          created_by_id: request.user?.id\n        })\n        .returning();\n\n      reply.code(201);\n      return {\n        status: 201,\n        message: \"Metric snapshot created successfully\",\n        data: result[0]\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to create metric snapshot\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Get snapshots for an initiative\n   */\n  async getInitiativeSnapshots(request, reply) {\n    try {\n      const { initiative_id } = request.params;\n\n      const result = await db\n        .select()\n        .from(qapi_metric_snapshots)\n        .where(and(\n          eq(qapi_metric_snapshots.initiative_id, parseInt(initiative_id)),\n          isNull(qapi_metric_snapshots.deleted_at)\n        ))\n        .orderBy(asc(qapi_metric_snapshots.snapshot_date));\n\n      return {\n        status: 200,\n        message: \"Initiative snapshots retrieved successfully\",\n        data: result\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to retrieve initiative snapshots\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  // ==================== INITIATIVE DEPENDENCIES ====================\n\n  /**\n   * Add initiative dependency\n   */\n  async addInitiativeDependency(request, reply) {\n    try {\n      const data = request.body;\n\n      // Prevent self-dependency\n      if (data.initiative_id === data.depends_on_id) {\n        reply.code(400);\n        return { status: 400, message: \"An initiative cannot depend on itself\" };\n      }\n\n      // Check for circular dependency\n      const hasCircular = await this._checkCircularDependency(data.initiative_id, data.depends_on_id);\n      if (hasCircular) {\n        reply.code(400);\n        return { status: 400, message: \"This would create a circular dependency\" };\n      }\n\n      const result = await db\n        .insert(qapi_initiative_dependencies)\n        .values({\n          ...data,\n          created_by_id: request.user?.id\n        })\n        .returning();\n\n      reply.code(201);\n      return {\n        status: 201,\n        message: \"Initiative dependency added successfully\",\n        data: result[0]\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to add initiative dependency\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Remove initiative dependency\n   */\n  async removeInitiativeDependency(request, reply) {\n    try {\n      const { id } = request.params;\n\n      const result = await db\n        .update(qapi_initiative_dependencies)\n        .set({\n          deleted_at: new Date(),\n          updated_by_id: request.user?.id\n        })\n        .where(and(\n          eq(qapi_initiative_dependencies.id, parseInt(id)),\n          isNull(qapi_initiative_dependencies.deleted_at)\n        ))\n        .returning();\n\n      if (result.length === 0) {\n        reply.code(404);\n        return { status: 404, message: \"Dependency not found\" };\n      }\n\n      return {\n        status: 200,\n        message: \"Initiative dependency removed successfully\"\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to remove initiative dependency\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  // ==================== WEBHOOKS MANAGEMENT ====================\n\n  /**\n   * Get all webhooks\n   */\n  async getAllWebhooks(request, reply) {\n    try {\n      const { include_inactive } = request.query;\n\n      let conditions = [isNull(qapi_webhooks.deleted_at)];\n\n      if (!include_inactive) {\n        conditions.push(eq(qapi_webhooks.is_active, true));\n      }\n\n      const result = await db\n        .select()\n        .from(qapi_webhooks)\n        .where(and(...conditions))\n        .orderBy(asc(qapi_webhooks.name));\n\n      return {\n        status: 200,\n        message: \"Webhooks retrieved successfully\",\n        data: result\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to retrieve webhooks\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Create webhook\n   */\n  async createWebhook(request, reply) {\n    try {\n      const data = request.body;\n\n      const result = await db\n        .insert(qapi_webhooks)\n        .values({\n          ...data,\n          created_by_id: request.user?.id\n        })\n        .returning();\n\n      reply.code(201);\n      return {\n        status: 201,\n        message: \"Webhook created successfully\",\n        data: result[0]\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to create webhook\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Update webhook\n   */\n  async updateWebhook(request, reply) {\n    try {\n      const { id } = request.params;\n      const data = request.body;\n\n      const result = await db\n        .update(qapi_webhooks)\n        .set({\n          ...data,\n          updated_by_id: request.user?.id,\n          updatedAt: new Date()\n        })\n        .where(and(\n          eq(qapi_webhooks.id, parseInt(id)),\n          isNull(qapi_webhooks.deleted_at)\n        ))\n        .returning();\n\n      if (result.length === 0) {\n        reply.code(404);\n        return { status: 404, message: \"Webhook not found\" };\n      }\n\n      return {\n        status: 200,\n        message: \"Webhook updated successfully\",\n        data: result[0]\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to update webhook\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Delete webhook (soft delete)\n   */\n  async deleteWebhook(request, reply) {\n    try {\n      const { id } = request.params;\n\n      const result = await db\n        .update(qapi_webhooks)\n        .set({\n          deleted_at: new Date(),\n          updated_by_id: request.user?.id\n        })\n        .where(and(\n          eq(qapi_webhooks.id, parseInt(id)),\n          isNull(qapi_webhooks.deleted_at)\n        ))\n        .returning();\n\n      if (result.length === 0) {\n        reply.code(404);\n        return { status: 404, message: \"Webhook not found\" };\n      }\n\n      return {\n        status: 200,\n        message: \"Webhook deleted successfully\"\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to delete webhook\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  /**\n   * Get webhook events\n   */\n  async getWebhookEvents(request, reply) {\n    try {\n      const { webhook_id, success, from_date, to_date, limit = 100 } = request.query;\n\n      let conditions = [];\n\n      if (webhook_id) {\n        conditions.push(eq(qapi_webhook_events.webhook_id, parseInt(webhook_id)));\n      }\n      if (success !== undefined) {\n        conditions.push(eq(qapi_webhook_events.success, success === 'true'));\n      }\n      if (from_date) {\n        conditions.push(gte(qapi_webhook_events.triggered_at, new Date(from_date)));\n      }\n      if (to_date) {\n        conditions.push(lte(qapi_webhook_events.triggered_at, new Date(to_date)));\n      }\n\n      const result = await db\n        .select()\n        .from(qapi_webhook_events)\n        .where(conditions.length > 0 ? and(...conditions) : undefined)\n        .orderBy(desc(qapi_webhook_events.triggered_at))\n        .limit(parseInt(limit));\n\n      return {\n        status: 200,\n        message: \"Webhook events retrieved successfully\",\n        data: result\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to retrieve webhook events\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  // ==================== CHANGE LOG ====================\n\n  /**\n   * Get change log for an entity\n   */\n  async getChangeLog(request, reply) {\n    try {\n      const { entity_type, entity_id, from_date, to_date, limit = 100 } = request.query;\n\n      let conditions = [];\n\n      if (entity_type) {\n        conditions.push(eq(qapi_change_log.entity_type, entity_type));\n      }\n      if (entity_id) {\n        conditions.push(eq(qapi_change_log.entity_id, parseInt(entity_id)));\n      }\n      if (from_date) {\n        conditions.push(gte(qapi_change_log.changed_at, new Date(from_date)));\n      }\n      if (to_date) {\n        conditions.push(lte(qapi_change_log.changed_at, new Date(to_date)));\n      }\n\n      const result = await db\n        .select()\n        .from(qapi_change_log)\n        .where(conditions.length > 0 ? and(...conditions) : undefined)\n        .orderBy(desc(qapi_change_log.changed_at))\n        .limit(parseInt(limit));\n\n      return {\n        status: 200,\n        message: \"Change log retrieved successfully\",\n        data: result\n      };\n    } catch (error) {\n      request.log.error(error);\n      reply.code(500);\n      return {\n        status: 500,\n        message: \"Failed to retrieve change log\",\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      };\n    }\n  }\n\n  // ==================== HELPER METHODS ====================\n\n  /**\n   * Evaluate thresholds for a metric value\n   */\n  _evaluateThresholds(value, thresholds) {\n    let status = 'OK';\n    let meetsTarget = true;\n    let breached = false;\n\n    for (const threshold of thresholds) {\n      const thresholdValue = parseFloat(threshold.threshold_value);\n      const currentValue = parseFloat(value);\n      let isBreach = false;\n\n      switch (threshold.comparison_operator) {\n        case 'GT':\n          isBreach = currentValue > thresholdValue;\n          break;\n        case 'GTE':\n          isBreach = currentValue >= thresholdValue;\n          break;\n        case 'LT':\n          isBreach = currentValue < thresholdValue;\n          break;\n        case 'LTE':\n          isBreach = currentValue <= thresholdValue;\n          break;\n        case 'EQ':\n          isBreach = currentValue === thresholdValue;\n          break;\n        case 'NEQ':\n          isBreach = currentValue !== thresholdValue;\n          break;\n        case 'BETWEEN':\n          const min = parseFloat(threshold.threshold_value_min);\n          const max = parseFloat(threshold.threshold_value_max);\n          isBreach = currentValue >= min && currentValue <= max;\n          break;\n      }\n\n      if (isBreach) {\n        breached = true;\n        if (threshold.threshold_type === 'CRITICAL') {\n          status = 'CRITICAL';\n          meetsTarget = false;\n        } else if (threshold.threshold_type === 'WARNING' && status !== 'CRITICAL') {\n          status = 'WARNING';\n        } else if (threshold.threshold_type === 'SLA') {\n          status = 'SLA_BREACH';\n          meetsTarget = false;\n        } else if (threshold.threshold_type === 'TARGET') {\n          meetsTarget = false;\n        }\n      }\n    }\n\n    return { status, meetsTarget, breached };\n  }\n\n  /**\n   * Trigger webhooks for threshold breach\n   */\n  async _triggerThresholdWebhooks(metricId, value, evaluation) {\n    try {\n      const webhooks = await db\n        .select()\n        .from(qapi_webhooks)\n        .where(and(\n          eq(qapi_webhooks.is_active, true),\n          isNull(qapi_webhooks.deleted_at)\n        ));\n\n      for (const webhook of webhooks) {\n        const triggerOn = webhook.trigger_on || [];\n        if (!triggerOn.includes('THRESHOLD_BREACH')) continue;\n\n        // Log webhook event (actual HTTP call would be done by a worker)\n        await db\n          .insert(qapi_webhook_events)\n          .values({\n            webhook_id: webhook.id,\n            event_type: 'THRESHOLD_BREACH',\n            triggered_at: new Date(),\n            success: false, // Will be updated by worker\n            trigger_context: {\n              metric_id: metricId,\n              value,\n              evaluation\n            }\n          });\n\n        // Update webhook last triggered\n        await db\n          .update(qapi_webhooks)\n          .set({\n            last_triggered_at: new Date()\n          })\n          .where(eq(qapi_webhooks.id, webhook.id));\n      }\n    } catch (error) {\n      // Log error but don't fail the main operation\n      console.error('Failed to trigger webhooks:', error);\n    }\n  }\n\n  /**\n   * Check for circular dependency\n   */\n  async _checkCircularDependency(initiativeId, dependsOnId) {\n    // Get all dependencies of dependsOnId recursively\n    const visited = new Set();\n    const queue = [dependsOnId];\n\n    while (queue.length > 0) {\n      const current = queue.shift();\n      if (current === initiativeId) {\n        return true; // Circular dependency found\n      }\n\n      if (visited.has(current)) continue;\n      visited.add(current);\n\n      const deps = await db\n        .select()\n        .from(qapi_initiative_dependencies)\n        .where(and(\n          eq(qapi_initiative_dependencies.initiative_id, current),\n          isNull(qapi_initiative_dependencies.deleted_at)\n        ));\n\n      for (const dep of deps) {\n        queue.push(dep.depends_on_id);\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Log a change to the audit log\n   */\n  async _logChange(request, entityType, entityId, action, oldValue, newValue) {\n    try {\n      const changes = {};\n      if (oldValue && newValue) {\n        for (const key of Object.keys(newValue)) {\n          if (JSON.stringify(oldValue[key]) !== JSON.stringify(newValue[key])) {\n            changes[key] = { old: oldValue[key], new: newValue[key] };\n          }\n        }\n      }\n\n      await db\n        .insert(qapi_change_log)\n        .values({\n          entity_type: entityType,\n          entity_id: entityId,\n          action,\n          changes: Object.keys(changes).length > 0 ? changes : null,\n          changed_by_id: request.user?.id || 'system',\n          ip_address: request.ip,\n          user_agent: request.headers?.['user-agent']\n        });\n    } catch (error) {\n      // Log error but don't fail the main operation\n      console.error('Failed to log change:', error);\n    }\n  }\n}\n\nexport default new QAPIMetricsController();\n"
}

You've hit your limit Â· resets 4pm (America/Los_Angeles)