{
  "id": "api-documentation",
  "category": "Documentation",
  "title": "API Documentation",
  "description": "Generate Comprehensive OpenAPI 3.0 Specification for REST API\n\nCreate complete, production-ready OpenAPI/Swagger documentation for all existing REST API endpoints in the application, ensuring accuracy, maintainability, and compliance with OpenAPI 3.0 standards.\n\nRequirements:\n\nEndpoint Documentation:\n- Discover and catalog all REST API endpoints across the codebase (GET, POST, PUT, PATCH, DELETE, OPTIONS)\n- Document complete path structures with route parameters\n- Add clear, concise descriptions explaining each endpoint's purpose, behavior, and business logic\n- Include practical request/response examples for each endpoint\n- Organize endpoints using logical tag grouping (e.g., \"Users\", \"Authentication\", \"Products\")\n\nSchema Definitions:\n- Define reusable component schemas for all data models\n- Document request body schemas with complete property definitions\n- Define response schemas for success cases (200, 201, 204) and all error scenarios\n- Specify data types, formats, and enums for all properties\n- Use schema composition ($ref, allOf, oneOf, anyOf) to reduce duplication\n\nParameters and Validation:\n- Document all path parameters with type, format, and validation rules\n- Catalog query parameters including optional filters, pagination, sorting, and search parameters\n- Define required and optional headers (Content-Type, Accept, custom headers)\n- Specify validation constraints: required fields, min/max lengths, regex patterns, numeric ranges, array constraints\n- Add examples for complex parameter combinations\n\nAuthentication and Security:\n- Define security schemes (Bearer tokens, API keys, OAuth2, Basic Auth)\n- Apply security requirements globally or per-endpoint\n- Document authorization levels and permission requirements\n- Include examples of authentication headers\n\nError Handling:\n- Document error response schemas with consistent structure\n- Define standard HTTP status codes: 400 (Bad Request), 401 (Unauthorized), 403 (Forbidden), 404 (Not Found), 409 (Conflict), 422 (Validation Error), 429 (Rate Limited), 500 (Internal Server Error), 503 (Service Unavailable)\n- Provide error response examples with realistic error messages\n- Include error code enumerations if the API uses custom error codes\n\nAPI Metadata:\n- Set API version information (semantic versioning)\n- Configure server URLs for different environments (development, staging, production)\n- Add contact information and license details\n- Include API terms of service if applicable\n\nSpecial Cases:\n- Document file upload endpoints with multipart/form-data content type and file parameter specifications\n- Handle file download endpoints with appropriate content types (application/pdf, image/*, etc.) and binary responses\n- Specify pagination metadata for list endpoints (page, limit, offset, cursor-based)\n- Document filtering, sorting, and search query syntax\n- Mark deprecated endpoints with deprecation warnings and migration guidance\n- Include rate limiting information (requests per minute/hour, quota headers)\n- Document webhook endpoints if applicable\n- Handle batch operation endpoints\n\nIntegration and Tooling:\n- Integrate Swagger UI for interactive API documentation and testing (accessible at /api-docs, /swagger, or /docs)\n- Consider ReDoc as alternative documentation UI for enhanced readability\n- Set up validation tooling to ensure spec correctness (openapi-validator, spectral)\n- Implement automated spec generation or validation in CI/CD pipeline\n- Choose implementation approach: code-first (annotations/decorators generating spec) or spec-first (spec generates validation/routing)\n\nMaintainability:\n- Establish clear process for keeping documentation synchronized with code changes\n- Add documentation requirements to definition of done for API changes\n- Consider automated testing that validates API responses against OpenAPI spec\n- Use schema references ($ref) extensively to maintain single source of truth\n- Split large specifications into multiple files if needed (using $ref to external files)\n\nEdge Cases and Considerations:\n- Handle polymorphic responses (different schemas based on conditions)\n- Document conditional required fields\n- Specify CORS configuration if relevant to API consumers\n- Include WebSocket endpoints if the API supports them\n- Document idempotency keys for write operations\n- Handle API gateway or proxy configuration details\n- Account for content negotiation (multiple response formats like JSON, XML)\n\nDeliverables:\n- OpenAPI 3.0.x specification file (openapi.yaml or openapi.json)\n- Functional Swagger UI endpoint integrated into the application\n- Developer documentation explaining how to update and maintain the specification\n- Validation script or CI check to ensure spec validity\n- Migration guide if updating from Swagger 2.0 or creating documentation for the first time\n\nSuccess Criteria:\n- All existing endpoints are documented with complete request/response schemas\n- Swagger UI successfully renders and allows testing of all endpoints\n- Documentation passes OpenAPI 3.0 validation without errors\n- Development team can easily maintain documentation alongside code changes",
  "status": "completed",
  "priority": 1,
  "complexity": "moderate",
  "dependencies": [
    "fastify-server-bootstrap"
  ],
  "createdAt": "2025-12-31T05:55:26.264Z",
  "updatedAt": "2026-01-01T00:06:41.123Z",
  "skipTests": false,
  "model": "opus",
  "thinkingLevel": "none",
  "imagePaths": [],
  "textFilePaths": [],
  "branchName": "main",
  "planningMode": "skip",
  "requirePlanApproval": false,
  "startedAt": "2026-01-01T00:02:28.722Z"
}